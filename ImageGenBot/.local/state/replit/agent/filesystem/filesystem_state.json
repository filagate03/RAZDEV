{"file_contents":{"app/handlers/admin.py":{"content":"from aiogram import Router, F\nfrom aiogram.filters import Command\nfrom aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.fsm.state import State, StatesGroup\nfrom app.database import async_session_maker\nfrom app.repositories import UserRepository, TransactionRepository, CardPaymentRequestRepository, CardPaymentInstructionRepository\nfrom app.keyboards.inline import admin_keyboard, back_to_main_keyboard\nfrom app.keyboards.reply import BUTTON_ADMIN\nfrom app.config import settings\nfrom sqlalchemy import func, select\nfrom app.models import User, Transaction\nimport logging\n\nlogger = logging.getLogger(__name__)\nrouter = Router()\n\n\ndef is_admin(chat_id: int) -> bool:\n    \"\"\"Check if user is admin\"\"\"\n    admin_ids = [int(admin_id) for admin_id in settings.ADMINS.split(\",\") if admin_id.strip()]\n    return chat_id in admin_ids\n\n\n@router.message(F.text == BUTTON_ADMIN)\nasync def show_admin_panel_message(message: Message):\n    \"\"\"Show admin panel (from reply keyboard button)\"\"\"\n    if not is_admin(message.from_user.id):\n        await message.answer(\"‚ùå –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏\")\n        return\n    \n    text = (\n        \"‚öôÔ∏è –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å\\n\\n\"\n        \"–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:\"\n    )\n    \n    await message.answer(text, reply_markup=admin_keyboard())\n\n\nclass AdminStates(StatesGroup):\n    waiting_for_admin_id = State()\n    waiting_for_payment_response = State()\n    waiting_for_instruction_text = State()\n    waiting_for_requisites = State()\n\n\ndef is_admin_filter():\n    \"\"\"Filter to check if user is admin\"\"\"\n    async def _filter(message: Message, is_admin: bool):\n        return is_admin\n    return _filter\n\n\n@router.message(Command(\"admin\"))\nasync def cmd_admin(message: Message):\n    \"\"\"Admin panel command\"\"\"\n    if not is_admin(message.from_user.id):\n        await message.answer(\"‚ùå –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏\")\n        return\n    \n    text = (\n        \"‚öôÔ∏è –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å\\n\\n\"\n        \"–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:\"\n    )\n    \n    await message.answer(text, reply_markup=admin_keyboard())\n\n\n@router.callback_query(F.data == \"admin_stats\")\nasync def show_admin_stats(callback: CallbackQuery):\n    \"\"\"Show admin statistics\"\"\"\n    if not is_admin(callback.from_user.id):\n        await callback.answer(\"–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞\", show_alert=True)\n        return\n    \n    async with async_session_maker() as session:\n        total_users = await session.scalar(select(func.count(User.id)))\n        \n        total_balance = await session.scalar(select(func.sum(User.balance))) or 0\n        \n        total_transactions = await session.scalar(select(func.count(Transaction.id)))\n        \n        total_earned = await session.scalar(\n            select(func.sum(Transaction.amount)).where(Transaction.amount > 0)\n        ) or 0\n        \n        total_spent = await session.scalar(\n            select(func.sum(Transaction.amount)).where(Transaction.amount < 0)\n        ) or 0\n    \n    text = (\n        \"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—Ç–∞\\n\\n\"\n        f\"üë• –í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {total_users}\\n\"\n        f\"üí∞ –°—É–º–º–∞—Ä–Ω—ã–π –±–∞–ª–∞–Ω—Å: {total_balance} —Ç–æ–∫–µ–Ω–æ–≤\\n\"\n        f\"üí≥ –í—Å–µ–≥–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π: {total_transactions}\\n\"\n        f\"üìà –ö—É–ø–ª–µ–Ω–æ —Ç–æ–∫–µ–Ω–æ–≤: {total_earned}\\n\"\n        f\"üìâ –ü–æ—Ç—Ä–∞—á–µ–Ω–æ —Ç–æ–∫–µ–Ω–æ–≤: {abs(total_spent)}\\n\"\n        f\"üíµ –ü—Ä–∏–±—ã–ª—å: {total_earned + total_spent} —Ç–æ–∫–µ–Ω–æ–≤\\n\"\n    )\n    \n    await callback.message.edit_text(text, reply_markup=back_to_main_keyboard())\n    await callback.answer()\n\n\n@router.callback_query(F.data == \"admin_users\")\nasync def show_admin_users(callback: CallbackQuery):\n    \"\"\"Show users list\"\"\"\n    if not is_admin(callback.from_user.id):\n        await callback.answer(\"–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞\", show_alert=True)\n        return\n    \n    async with async_session_maker() as session:\n        user_repo = UserRepository(session)\n        users = await user_repo.get_all_users()\n        \n        users_sorted = sorted(users, key=lambda u: u.balance, reverse=True)[:10]\n    \n    text = \"üë• –¢–æ–ø-10 –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ –±–∞–ª–∞–Ω—Å—É:\\n\\n\"\n    \n    for i, user in enumerate(users_sorted, 1):\n        username = f\"@{user.username}\" if user.username else f\"ID: {user.chat_id}\"\n        text += f\"{i}. {username} - {user.balance} —Ç–æ–∫–µ–Ω–æ–≤\\n\"\n    \n    await callback.message.edit_text(text, reply_markup=back_to_main_keyboard())\n    await callback.answer()\n\n\n@router.callback_query(F.data == \"admin_transactions\")\nasync def show_admin_transactions(callback: CallbackQuery):\n    \"\"\"Show recent transactions\"\"\"\n    if not is_admin(callback.from_user.id):\n        await callback.answer(\"–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞\", show_alert=True)\n        return\n    \n    async with async_session_maker() as session:\n        result = await session.execute(\n            select(Transaction).order_by(Transaction.created_at.desc()).limit(10)\n        )\n        transactions = result.scalars().all()\n    \n    text = \"üí∞ –ü–æ—Å–ª–µ–¥–Ω–∏–µ 10 —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π:\\n\\n\"\n    \n    for tx in transactions:\n        sign = \"+\" if tx.amount > 0 else \"\"\n        text += f\"{sign}{tx.amount} —Ç–æ–∫–µ–Ω–æ–≤ - {tx.reason}\\n\"\n        text += f\"  {tx.created_at.strftime('%d.%m.%Y %H:%M')}\\n\\n\"\n    \n    await callback.message.edit_text(text, reply_markup=back_to_main_keyboard())\n    await callback.answer()\n\n\n@router.callback_query(F.data == \"admin_manage\")\nasync def show_admin_manage(callback: CallbackQuery):\n    \"\"\"Show admin management\"\"\"\n    if not is_admin(callback.from_user.id):\n        await callback.answer(\"–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞\", show_alert=True)\n        return\n    \n    async with async_session_maker() as session:\n        user_repo = UserRepository(session)\n        admins = await user_repo.get_all_admins()\n    \n    text = \"üë®‚Äçüíº –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∞–¥–º–∏–Ω–∞–º–∏\\n\\n\"\n    text += \"–¢–µ–∫—É—â–∏–µ –∞–¥–º–∏–Ω—ã:\\n\"\n    \n    for admin in admins:\n        username = f\"@{admin.username}\" if admin.username else f\"ID: {admin.chat_id}\"\n        text += f\"‚Ä¢ {username} ({admin.chat_id})\\n\"\n    \n    text += \"\\nüìù –î–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∞–¥–º–∏–Ω–∞ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ:\\n/add_admin [ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è]\\n\\n\"\n    text += \"‚ùå –î–ª—è —É–¥–∞–ª–µ–Ω–∏—è –∞–¥–º–∏–Ω–∞ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ:\\n/remove_admin [ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è]\"\n    \n    await callback.message.edit_text(text, reply_markup=back_to_main_keyboard())\n    await callback.answer()\n\n\n@router.message(Command(\"add_admin\"))\nasync def cmd_add_admin(message: Message):\n    \"\"\"Add new admin\"\"\"\n    if not is_admin(message.from_user.id):\n        await message.answer(\"‚ùå –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥–µ\")\n        return\n    \n    args = message.text.split()\n    if len(args) < 2:\n        await message.answer(\"‚ùå –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /add_admin <chat_id>\")\n        return\n    \n    try:\n        new_admin_id = int(args[1])\n    except ValueError:\n        await message.answer(\"‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç ID\")\n        return\n    \n    async with async_session_maker() as session:\n        user_repo = UserRepository(session)\n        user = await user_repo.get_by_chat_id(new_admin_id)\n        \n        if not user:\n            await message.answer(\"‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –û–Ω –¥–æ–ª–∂–µ–Ω —Å–Ω–∞—á–∞–ª–∞ –∑–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞.\")\n            return\n        \n        if user.is_admin:\n            await message.answer(\"‚ö†Ô∏è –≠—Ç–æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –∞–¥–º–∏–Ω\")\n            return\n        \n        await user_repo.set_admin(new_admin_id, True)\n    \n    await message.answer(f\"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {new_admin_id} —Ç–µ–ø–µ—Ä—å –∞–¥–º–∏–Ω!\")\n\n\n@router.message(Command(\"remove_admin\"))\nasync def cmd_remove_admin(message: Message):\n    \"\"\"Remove admin\"\"\"\n    if not is_admin(message.from_user.id):\n        await message.answer(\"‚ùå –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥–µ\")\n        return\n    \n    args = message.text.split()\n    if len(args) < 2:\n        await message.answer(\"‚ùå –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /remove_admin <chat_id>\")\n        return\n    \n    try:\n        admin_id = int(args[1])\n    except ValueError:\n        await message.answer(\"‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç ID\")\n        return\n    \n    if admin_id == message.from_user.id:\n        await message.answer(\"‚ùå –í—ã –Ω–µ –º–æ–∂–µ—Ç–µ —É–¥–∞–ª–∏—Ç—å —Å–µ–±—è –∏–∑ –∞–¥–º–∏–Ω–æ–≤\")\n        return\n    \n    async with async_session_maker() as session:\n        user_repo = UserRepository(session)\n        await user_repo.set_admin(admin_id, False)\n    \n    await message.answer(f\"‚úÖ –ê–¥–º–∏–Ω {admin_id} —É–¥–∞–ª–µ–Ω\")\n\n\n@router.callback_query(F.data == \"admin_payment_requests\")\nasync def show_payment_requests(callback: CallbackQuery):\n    \"\"\"Show pending payment requests\"\"\"\n    if not is_admin(message.from_user.id):\n        await callback.answer(\"–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞\", show_alert=True)\n        return\n    \n    async with async_session_maker() as session:\n        payment_repo = CardPaymentRequestRepository(session)\n        requests = await payment_repo.get_pending()\n        \n        if not requests:\n            text = \"üí≥ –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞—è–≤–æ–∫ –Ω–∞ –æ–ø–ª–∞—Ç—É\"\n            await callback.message.edit_text(text, reply_markup=back_to_main_keyboard())\n            await callback.answer()\n            return\n        \n        text = \"üí≥ –ê–∫—Ç–∏–≤–Ω—ã–µ –∑–∞—è–≤–∫–∏ –Ω–∞ –æ–ø–ª–∞—Ç—É:\\n\\n\"\n        \n        buttons = []\n        for req in requests[:10]:\n            user_repo = UserRepository(session)\n            user = await session.get(User, req.user_id)\n            \n            username = f\"@{user.username}\" if user and user.username else f\"ID: {user.chat_id if user else 'N/A'}\"\n            card_type = \"üá∑üá∫ RU\" if req.card_type == \"ru\" else \"üåç INTL\"\n            price = f\"{req.price_rub} ‚ÇΩ\" if req.price_rub else f\"${req.price_usd}\"\n            \n            text += f\"#{req.id} {username}\\n\"\n            text += f\"   {req.tokens_amount} —Ç–æ–∫–µ–Ω–æ–≤ ‚Ä¢ {card_type} ‚Ä¢ {price}\\n\\n\"\n            \n            buttons.append([InlineKeyboardButton(\n                text=f\"#{req.id} - {username}\",\n                callback_data=f\"respond_{req.id}\"\n            )])\n        \n        buttons.append([InlineKeyboardButton(text=\"‚óÄÔ∏è –ê–¥–º–∏–Ω –º–µ–Ω—é\", callback_data=\"admin_menu\")])\n        keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)\n        \n        await callback.message.edit_text(text, reply_markup=keyboard)\n    await callback.answer()\n\n\n@router.callback_query(F.data.startswith(\"respond_\"))\nasync def respond_to_payment_request(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Respond to payment request\"\"\"\n    if not is_admin(message.from_user.id):\n        await callback.answer(\"–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞\", show_alert=True)\n        return\n    \n    request_id = int(callback.data.split(\"_\")[1])\n    \n    async with async_session_maker() as session:\n        payment_repo = CardPaymentRequestRepository(session)\n        request = await payment_repo.get_by_id(request_id)\n        \n        if not request:\n            await callback.answer(\"–ó–∞—è–≤–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞\", show_alert=True)\n            return\n        \n        user = await session.get(User, request.user_id)\n        if not user:\n            await callback.answer(\"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω\", show_alert=True)\n            return\n        \n        card_type = \"–†–æ—Å—Å–∏–π—Å–∫–∞—è\" if request.card_type == \"ru\" else \"–ú–µ–∂–¥—É–Ω–∞—Ä–æ–¥–Ω–∞—è\"\n        price = f\"{request.price_rub} ‚ÇΩ\" if request.price_rub else f\"${request.price_usd}\"\n        \n        text = (\n            f\"üí≥ –ó–∞—è–≤–∫–∞ #{request.id}\\n\\n\"\n            f\"üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: @{user.username if user.username else user.chat_id}\\n\"\n            f\"üÜî Chat ID: {user.chat_id}\\n\"\n            f\"üì¶ –ü–∞–∫–µ—Ç: {request.tokens_amount} —Ç–æ–∫–µ–Ω–æ–≤\\n\"\n            f\"üí≥ –¢–∏–ø –∫–∞—Ä—Ç—ã: {card_type}\\n\"\n            f\"üí∞ –°—É–º–º–∞: {price}\\n\\n\"\n            f\"üìù –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å —Ä–µ–∫–≤–∏–∑–∏—Ç–∞–º–∏ –¥–ª—è –æ–ø–ª–∞—Ç—ã.\\n\"\n            f\"–û–Ω–æ –±—É–¥–µ—Ç –ø–µ—Ä–µ—Å–ª–∞–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é.\"\n        )\n    \n    await state.update_data(request_id=request_id, user_chat_id=user.chat_id)\n    await state.set_state(AdminStates.waiting_for_payment_response)\n    \n    await callback.message.edit_text(text, reply_markup=back_to_main_keyboard())\n    await callback.answer(\"–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ä–µ–∫–≤–∏–∑–∏—Ç—ã\")\n\n\n@router.message(AdminStates.waiting_for_payment_response)\nasync def process_payment_response(message: Message, state: FSMContext):\n    \"\"\"Process admin response with payment details\"\"\"\n    if not is_admin(message.from_user.id):\n        return\n    \n    data = await state.get_data()\n    request_id = data.get(\"request_id\")\n    user_chat_id = data.get(\"user_chat_id\")\n    \n    if not request_id or not user_chat_id:\n        await message.answer(\"‚ùå –û—à–∏–±–∫–∞: –¥–∞–Ω–Ω—ã–µ –∑–∞—è–≤–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã\")\n        await state.clear()\n        return\n    \n    response_text = message.text\n    \n    async with async_session_maker() as session:\n        payment_repo = CardPaymentRequestRepository(session)\n        await payment_repo.update_status(request_id, \"processing\", response_text)\n    \n    try:\n        user_message = (\n            f\"üí≥ –û—Ç–≤–µ—Ç –æ—Ç –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞:\\n\\n\"\n            f\"{response_text}\\n\\n\"\n            f\"–ü–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —á–µ–∫ –≤ –±–æ—Ç.\"\n        )\n        await message.bot.send_message(user_chat_id, user_message)\n        await message.answer(\"‚úÖ –û—Ç–≤–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é!\")\n    except Exception as e:\n        logger.error(f\"Failed to send message to user {user_chat_id}: {e}\")\n        await message.answer(f\"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}\")\n    \n    await state.clear()\n\n\n@router.callback_query(F.data == \"admin_menu\")\nasync def back_to_admin_menu(callback: CallbackQuery):\n    \"\"\"Back to admin menu\"\"\"\n    if not is_admin(callback.from_user.id):\n        await callback.answer(\"–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞\", show_alert=True)\n        return\n    \n    text = (\n        \"‚öôÔ∏è –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å\\n\\n\"\n        \"–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:\"\n    )\n    \n    await callback.message.edit_text(text, reply_markup=admin_keyboard())\n    await callback.answer()\n\n\n@router.callback_query(F.data == \"admin_payment_settings\")\nasync def show_payment_settings(callback: CallbackQuery):\n    \"\"\"Show payment settings menu\"\"\"\n    if not is_admin(callback.from_user.id):\n        await callback.answer(\"–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞\", show_alert=True)\n        return\n    \n    text = (\n        \"‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –æ–ø–ª–∞—Ç—ã\\n\\n\"\n        \"–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –∫–∞—Ä—Ç—ã –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Ä–µ–∫–≤–∏–∑–∏—Ç–æ–≤ –∏ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π:\"\n    )\n    \n    keyboard = InlineKeyboardMarkup(inline_keyboard=[\n        [InlineKeyboardButton(text=\"üá∑üá∫ –†–æ—Å—Å–∏–π—Å–∫–∏–µ –∫–∞—Ä—Ç—ã\", callback_data=\"edit_payment_ru\")],\n        [InlineKeyboardButton(text=\"üåç –ú–µ–∂–¥—É–Ω–∞—Ä–æ–¥–Ω—ã–µ –∫–∞—Ä—Ç—ã\", callback_data=\"edit_payment_intl\")],\n        [InlineKeyboardButton(text=\"‚óÄÔ∏è –ù–∞–∑–∞–¥\", callback_data=\"admin_menu\")]\n    ])\n    \n    await callback.message.edit_text(text, reply_markup=keyboard)\n    await callback.answer()\n\n\n@router.callback_query(F.data.in_([\"edit_payment_ru\", \"edit_payment_intl\"]))\nasync def edit_payment_instructions(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Edit payment instructions for specific card type\"\"\"\n    if not is_admin(callback.from_user.id):\n        await callback.answer(\"–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞\", show_alert=True)\n        return\n    \n    card_type = \"ru\" if callback.data == \"edit_payment_ru\" else \"intl\"\n    card_name = \"–†–æ—Å—Å–∏–π—Å–∫–∏–µ\" if card_type == \"ru\" else \"–ú–µ–∂–¥—É–Ω–∞—Ä–æ–¥–Ω—ã–µ\"\n    \n    async with async_session_maker() as session:\n        instr_repo = CardPaymentInstructionRepository(session)\n        instruction = await instr_repo.get_or_create(\n            card_type=card_type,\n            default_text=\"–ü–µ—Ä–µ–≤–µ–¥–∏—Ç–µ —É–∫–∞–∑–∞–Ω–Ω—É—é —Å—É–º–º—É –Ω–∞ —Ä–µ–∫–≤–∏–∑–∏—Ç—ã –Ω–∏–∂–µ –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–∫—Ä–∏–Ω—à–æ—Ç —á–µ–∫–∞.\",\n            default_requisites=\"2200 0000 2200 0000\" if card_type == \"ru\" else \"4111 1111 1111 1111\"\n        )\n    \n    text = (\n        f\"üí≥ {card_name} –∫–∞—Ä—Ç—ã\\n\\n\"\n        f\"üìù –¢–µ–∫—É—â–∏–π —Ç–µ–∫—Å—Ç –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏:\\n{instruction.instruction_text}\\n\\n\"\n        f\"üí≥ –¢–µ–∫—É—â–∏–µ —Ä–µ–∫–≤–∏–∑–∏—Ç—ã:\\n<code>{instruction.requisites}</code>\\n\\n\"\n        \"–ß—Ç–æ —Ö–æ—Ç–∏—Ç–µ –∏–∑–º–µ–Ω–∏—Ç—å?\"\n    )\n    \n    keyboard = InlineKeyboardMarkup(inline_keyboard=[\n        [InlineKeyboardButton(text=\"üìù –ò–∑–º–µ–Ω–∏—Ç—å —Ç–µ–∫—Å—Ç\", callback_data=f\"edit_text_{card_type}\")],\n        [InlineKeyboardButton(text=\"üí≥ –ò–∑–º–µ–Ω–∏—Ç—å —Ä–µ–∫–≤–∏–∑–∏—Ç—ã\", callback_data=f\"edit_req_{card_type}\")],\n        [InlineKeyboardButton(text=\"‚óÄÔ∏è –ù–∞–∑–∞–¥\", callback_data=\"admin_payment_settings\")]\n    ])\n    \n    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode=\"HTML\")\n    await callback.answer()\n\n\n@router.callback_query(F.data.startswith(\"edit_text_\"))\nasync def start_edit_text(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Start editing instruction text\"\"\"\n    if not is_admin(message.from_user.id):\n        await callback.answer(\"–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞\", show_alert=True)\n        return\n    \n    card_type = callback.data.split(\"_\")[2]\n    await state.update_data(card_type=card_type)\n    await state.set_state(AdminStates.waiting_for_instruction_text)\n    \n    card_name = \"—Ä–æ—Å—Å–∏–π—Å–∫–∏—Ö\" if card_type == \"ru\" else \"–º–µ–∂–¥—É–Ω–∞—Ä–æ–¥–Ω—ã—Ö\"\n    \n    text = (\n        f\"üìù –í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π —Ç–µ–∫—Å—Ç –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –¥–ª—è {card_name} –∫–∞—Ä—Ç:\\n\\n\"\n        \"–≠—Ç–æ—Ç —Ç–µ–∫—Å—Ç –±—É–¥–µ—Ç –ø–æ–∫–∞–∑–∞–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –ø–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ –ø–∞–∫–µ—Ç–∞.\"\n    )\n    \n    keyboard = InlineKeyboardMarkup(inline_keyboard=[\n        [InlineKeyboardButton(text=\"‚ùå –û—Ç–º–µ–Ω–∏—Ç—å\", callback_data=\"admin_payment_settings\")]\n    ])\n    \n    await callback.message.edit_text(text, reply_markup=keyboard)\n    await callback.answer()\n\n\n@router.message(AdminStates.waiting_for_instruction_text)\nasync def receive_instruction_text(message: Message, state: FSMContext):\n    \"\"\"Receive new instruction text\"\"\"\n    if not is_admin(message.from_user.id):\n        return\n    \n    data = await state.get_data()\n    card_type = data.get(\"card_type\")\n    \n    if not card_type:\n        await message.answer(\"‚ùå –û—à–∏–±–∫–∞: —Ç–∏–ø –∫–∞—Ä—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω\")\n        await state.clear()\n        return\n    \n    new_text = message.text\n    \n    async with async_session_maker() as session:\n        instr_repo = CardPaymentInstructionRepository(session)\n        await instr_repo.update(card_type, instruction_text=new_text)\n    \n    card_name = \"—Ä–æ—Å—Å–∏–π—Å–∫–∏—Ö\" if card_type == \"ru\" else \"–º–µ–∂–¥—É–Ω–∞—Ä–æ–¥–Ω—ã—Ö\"\n    await message.answer(\n        f\"‚úÖ –¢–µ–∫—Å—Ç –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –¥–ª—è {card_name} –∫–∞—Ä—Ç –æ–±–Ω–æ–≤–ª–µ–Ω!\\n\\n\"\n        f\"–ù–æ–≤—ã–π —Ç–µ–∫—Å—Ç:\\n{new_text}\",\n        reply_markup=InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"‚óÄÔ∏è –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏\", callback_data=\"admin_payment_settings\")]\n        ])\n    )\n    \n    await state.clear()\n\n\n@router.callback_query(F.data.startswith(\"edit_req_\"))\nasync def start_edit_requisites(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Start editing requisites\"\"\"\n    if not is_admin(message.from_user.id):\n        await callback.answer(\"–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞\", show_alert=True)\n        return\n    \n    card_type = callback.data.split(\"_\")[2]\n    await state.update_data(card_type=card_type)\n    await state.set_state(AdminStates.waiting_for_requisites)\n    \n    card_name = \"—Ä–æ—Å—Å–∏–π—Å–∫–∏—Ö\" if card_type == \"ru\" else \"–º–µ–∂–¥—É–Ω–∞—Ä–æ–¥–Ω—ã—Ö\"\n    \n    text = (\n        f\"üí≥ –í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–µ —Ä–µ–∫–≤–∏–∑–∏—Ç—ã –¥–ª—è {card_name} –∫–∞—Ä—Ç:\\n\\n\"\n        \"–ù–∞–ø—Ä–∏–º–µ—Ä: 2200 0000 2200 0000\\n\"\n        \"–ò–ª–∏: –°—á–µ—Ç Paypal: example@mail.com\"\n    )\n    \n    keyboard = InlineKeyboardMarkup(inline_keyboard=[\n        [InlineKeyboardButton(text=\"‚ùå –û—Ç–º–µ–Ω–∏—Ç—å\", callback_data=\"admin_payment_settings\")]\n    ])\n    \n    await callback.message.edit_text(text, reply_markup=keyboard)\n    await callback.answer()\n\n\n@router.message(AdminStates.waiting_for_requisites)\nasync def receive_requisites(message: Message, state: FSMContext):\n    \"\"\"Receive new requisites\"\"\"\n    if not is_admin(message.from_user.id):\n        return\n    \n    data = await state.get_data()\n    card_type = data.get(\"card_type\")\n    \n    if not card_type:\n        await message.answer(\"‚ùå –û—à–∏–±–∫–∞: —Ç–∏–ø –∫–∞—Ä—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω\")\n        await state.clear()\n        return\n    \n    new_requisites = message.text\n    \n    async with async_session_maker() as session:\n        instr_repo = CardPaymentInstructionRepository(session)\n        await instr_repo.update(card_type, requisites=new_requisites)\n    \n    card_name = \"—Ä–æ—Å—Å–∏–π—Å–∫–∏—Ö\" if card_type == \"ru\" else \"–º–µ–∂–¥—É–Ω–∞—Ä–æ–¥–Ω—ã—Ö\"\n    await message.answer(\n        f\"‚úÖ –†–µ–∫–≤–∏–∑–∏—Ç—ã –¥–ª—è {card_name} –∫–∞—Ä—Ç –æ–±–Ω–æ–≤–ª–µ–Ω—ã!\\n\\n\"\n        f\"–ù–æ–≤—ã–µ —Ä–µ–∫–≤–∏–∑–∏—Ç—ã:\\n<code>{new_requisites}</code>\",\n        reply_markup=InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"‚óÄÔ∏è –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏\", callback_data=\"admin_payment_settings\")]\n        ]),\n        parse_mode=\"HTML\"\n    )\n    \n    await state.clear()\n","size_bytes":21861},"app/keyboards/reply.py":{"content":"from aiogram.types import ReplyKeyboardMarkup, KeyboardButton, ReplyKeyboardRemove\n\n\nBUTTON_PHOTO = \"üì∏ –§–æ—Ç–æ\"\nBUTTON_VIDEO = \"üé¨ –í–∏–¥–µ–æ\"\nBUTTON_BUY_TOKENS = \"üí∞ –ü–æ–ø–æ–ª–Ω–∏—Ç—å —Ç–æ–∫–µ–Ω—ã\"\nBUTTON_BALANCE = \"üíé –ë–∞–ª–∞–Ω—Å\"\nBUTTON_REFERRALS = \"üë• –†–µ—Ñ–µ—Ä–∞–ª—ã\"\nBUTTON_HELP = \"‚ÑπÔ∏è –ü–æ–º–æ—â—å\"\nBUTTON_ADMIN = \"üë®‚Äçüíº –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å\"\n\n\ndef main_menu_keyboard(is_admin: bool = False) -> ReplyKeyboardMarkup:\n    \"\"\"\n    Main menu keyboard (persistent at bottom of screen)\n    \n    Args:\n        is_admin: Whether user is admin (shows admin panel button)\n    \"\"\"\n    buttons = [\n        [KeyboardButton(text=BUTTON_PHOTO), KeyboardButton(text=BUTTON_VIDEO)],\n        [KeyboardButton(text=BUTTON_BUY_TOKENS)],\n        [KeyboardButton(text=BUTTON_BALANCE), KeyboardButton(text=BUTTON_REFERRALS)],\n        [KeyboardButton(text=BUTTON_HELP)]\n    ]\n    \n    if is_admin:\n        buttons.append([KeyboardButton(text=BUTTON_ADMIN)])\n    \n    return ReplyKeyboardMarkup(\n        keyboard=buttons,\n        resize_keyboard=True,\n        one_time_keyboard=False,\n        input_field_placeholder=\"–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ...\"\n    )\n\n\ndef remove_keyboard() -> ReplyKeyboardRemove:\n    \"\"\"Remove reply keyboard\"\"\"\n    return ReplyKeyboardRemove()\n","size_bytes":1283},"app/services/image_api.py":{"content":"import aiohttp\nfrom typing import Optional, Dict\nfrom app.config import settings\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\nclass ImageGenerationAPI:\n    \"\"\"Service for working with Clothoff.net Image Generation API\"\"\"\n    \n    BASE_URL = settings.IMAGE_API_URL or \"https://api.grtkniv.net\"\n    TOKEN = settings.IMAGE_API_TOKEN\n    \n    @classmethod\n    def _headers(cls):\n        return {\"Authorization\": cls.TOKEN}\n    \n    @classmethod\n    async def generate_image(\n        cls,\n        photo_file_data: bytes,\n        webhook_url: str,\n        gen_id: str,\n        style: str = \"1\"\n    ) -> Optional[Dict]:\n        \"\"\"\n        Send photo for AI generation\n        \n        Args:\n            photo_file_data: Image bytes\n            webhook_url: URL for webhook callback\n            gen_id: Unique generation ID\n            style: Generation style (1-5)\n            \n        Returns:\n            API response dict or None on error\n        \"\"\"\n        style_configs = {\n            \"1\": {\"bodyType\": \"skinny\", \"breastSize\": \"small\", \"buttSize\": \"small\", \"cloth\": \"Naked\"},\n            \"2\": {\"bodyType\": \"normal\", \"breastSize\": \"medium\", \"buttSize\": \"medium\", \"cloth\": \"Naked\"},\n            \"3\": {\"bodyType\": \"athletic\", \"breastSize\": \"medium\", \"buttSize\": \"medium\", \"cloth\": \"Naked\"},\n            \"4\": {\"bodyType\": \"curvy\", \"breastSize\": \"large\", \"buttSize\": \"large\", \"cloth\": \"Naked\"},\n            \"5\": {\"bodyType\": \"plus_size\", \"breastSize\": \"large\", \"buttSize\": \"large\", \"cloth\": \"Naked\"}\n        }\n        \n        config = style_configs.get(style, style_configs[\"1\"])\n        \n        form = aiohttp.FormData()\n        form.add_field('image', photo_file_data, filename='photo.jpg', content_type='image/jpeg')\n        form.add_field('webhook', webhook_url)\n        form.add_field('id_gen', gen_id)\n        form.add_field('postGeneration', 'upscale')\n        form.add_field('agePeople', '18')\n        form.add_field('bodyType', config['bodyType'])\n        form.add_field('breastSize', config['breastSize'])\n        form.add_field('buttSize', config['buttSize'])\n        form.add_field('cloth', config['cloth'])\n        \n        async with aiohttp.ClientSession() as session:\n            try:\n                async with session.post(\n                    f\"{cls.BASE_URL}/api/imageGenerations/undress\",\n                    headers=cls._headers(),\n                    data=form,\n                    timeout=aiohttp.ClientTimeout(total=30)\n                ) as resp:\n                    if resp.status == 200:\n                        data = await resp.json()\n                        logger.info(f\"Generation started successfully: {gen_id}\")\n                        return data\n                    else:\n                        error_text = await resp.text()\n                        logger.error(f\"API error {resp.status}: {error_text}\")\n                        return None\n            except aiohttp.ClientError as e:\n                logger.error(f\"Generation request failed: {e}\")\n                return None\n            except Exception as e:\n                logger.error(f\"Unexpected error during generation: {e}\")\n                return None\n    \n    @classmethod\n    async def generate_video(\n        cls,\n        image_file_data: bytes,\n        webhook_url: str,\n        gen_id: str,\n        model_id: str = \"egncvJ0CJemcUX5\"\n    ) -> Optional[Dict]:\n        \"\"\"\n        Generate video from photo using animation model\n        \n        Args:\n            image_file_data: Photo bytes (not video!)\n            webhook_url: URL for webhook callback\n            gen_id: Unique generation ID\n            model_id: Animation model ID from /api/videoGenerations/models\n            \n        Returns:\n            API response dict or None on error\n        \"\"\"\n        form = aiohttp.FormData()\n        form.add_field('image', image_file_data, filename='photo.jpg', content_type='image/jpeg')\n        form.add_field('id_gen', gen_id)\n        form.add_field('name', model_id)\n        form.add_field('webhook', webhook_url)\n        \n        async with aiohttp.ClientSession() as session:\n            try:\n                async with session.post(\n                    f\"{cls.BASE_URL}/api/videoGenerations/animate\",\n                    headers=cls._headers(),\n                    data=form,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as resp:\n                    if resp.status == 200:\n                        data = await resp.json()\n                        logger.info(f\"Video generation started: {gen_id}, model: {model_id}\")\n                        return data\n                    else:\n                        error_text = await resp.text()\n                        logger.error(f\"Video API error {resp.status}: {error_text}\")\n                        return None\n            except aiohttp.ClientError as e:\n                logger.error(f\"Video generation request failed: {e}\")\n                return None\n            except Exception as e:\n                logger.error(f\"Unexpected error during video generation: {e}\")\n                return None\n    \n    @classmethod\n    async def get_video_models(cls) -> Optional[list]:\n        \"\"\"Get available video animation models\"\"\"\n        async with aiohttp.ClientSession() as session:\n            try:\n                async with session.get(\n                    f\"{cls.BASE_URL}/api/videoGenerations/models\",\n                    headers=cls._headers(),\n                    timeout=aiohttp.ClientTimeout(total=10)\n                ) as resp:\n                    if resp.status == 200:\n                        return await resp.json()\n                    else:\n                        logger.error(f\"Video models fetch error: {resp.status}\")\n                        return None\n            except Exception as e:\n                logger.error(f\"Video models fetch failed: {e}\")\n                return None\n    \n    @classmethod\n    async def get_collections(cls) -> Optional[Dict]:\n        \"\"\"Get available collections from API\"\"\"\n        async with aiohttp.ClientSession() as session:\n            try:\n                async with session.get(\n                    f\"{cls.BASE_URL}/api/imageGenerations/collections\",\n                    headers=cls._headers(),\n                    timeout=aiohttp.ClientTimeout(total=10)\n                ) as resp:\n                    if resp.status == 200:\n                        return await resp.json()\n                    else:\n                        logger.error(f\"Collections fetch error: {resp.status}\")\n                        return None\n            except Exception as e:\n                logger.error(f\"Collections fetch failed: {e}\")\n                return None\n","size_bytes":6692},"DEPLOYMENT.md":{"content":"# –†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ Deployment\n\n## –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π Deployment –Ω–∞ Replit\n\n–í–∞—à –±–æ—Ç –Ω–∞—Å—Ç—Ä–æ–µ–Ω –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –¥–µ–ø–ª–æ—è –Ω–∞ Replit Cloud Run (VM).\n\n### –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è\n\nDeployment –Ω–∞—Å—Ç—Ä–æ–µ–Ω –≤ —Ñ–∞–π–ª–µ `.replit`:\n\n```toml\n[deployment]\ndeploymentTarget = \"autoscale\"\nrun = [\"python3\", \"main.py\"]\nbuild = [\"pip\", \"install\", \"-r\", \"requirements.txt\"]\n```\n\n**–í–∞–∂–Ω–æ:**\n- `build` - —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –≤—Å–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –∏–∑ requirements.txt –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º\n- `run` - –∑–∞–ø—É—Å–∫–∞–µ—Ç –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ build\n- **Autoscale deployment** –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ—Ç—Å—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –Ω–∞–≥—Ä—É–∑–∫–∏ –∏ –æ–ø—Ç–∏–º–∞–ª–µ–Ω –¥–ª—è webhook-based –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π\n\n### Health Checks\n\n–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∏–º–µ–µ—Ç –¥–≤–∞ endpoint –¥–ª—è health checks:\n\n- **`/`** - –ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ (–≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç—É—Å –±–æ—Ç–∞)\n- **`/health`** - Health check endpoint (–≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç \"OK\")\n\n**–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:**\n- –°—Ä–µ–¥–Ω–∏–π response time: 1-3ms\n- –ë–µ–∑ —Ç—è–∂–µ–ª—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏\n- –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç—Å—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫\n- Endpoints –æ—Ç–≤–µ—á–∞—é—Ç –º–≥–Ω–æ–≤–µ–Ω–Ω–æ –¥–∞–∂–µ –µ—Å–ª–∏ –ë–î –µ—â–µ –Ω–µ –≥–æ—Ç–æ–≤–∞\n\n### –ö–∞–∫ –∑–∞–¥–µ–ø–ª–æ–∏—Ç—å\n\n1. **–£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ –≤—Å–µ —Å–µ–∫—Ä–µ—Ç—ã –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã** –≤ Replit Secrets:\n   - `BOT_TOKEN`\n   - `IMAGE_API_TOKEN`\n   - `IMAGE_API_URL`\n   - `CRYPTO_BOT_TOKEN`\n   - `WEBHOOK_SECRET`\n   - `ADMINS`\n\n2. **–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É \"Deploy\"** –≤ Replit UI\n\n3. **–í—ã–±–µ—Ä–∏—Ç–µ deployment target**: Autoscale (—É–∂–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω)\n\n4. **–ü–æ–¥–æ–∂–¥–∏—Ç–µ** –ø–æ–∫–∞ deployment –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è\n\n5. **–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏** —á—Ç–æ–±—ã —É–±–µ–¥–∏—Ç—å—Å—è —á—Ç–æ –±–æ—Ç –∑–∞–ø—É—Å—Ç–∏–ª—Å—è\n\n### –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–±–æ—Ç—ã\n\n–ü–æ—Å–ª–µ –¥–µ–ø–ª–æ—è –ø—Ä–æ–≤–µ—Ä—å—Ç–µ —á—Ç–æ:\n\n1. Health check —Ä–∞–±–æ—Ç–∞–µ—Ç:\n   ```bash\n   curl https://your-deployment-url.replit.app/health\n   ```\n   –î–æ–ª–∂–µ–Ω –≤–µ—Ä–Ω—É—Ç—å: `OK`\n\n2. –ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç:\n   ```bash\n   curl https://your-deployment-url.replit.app/\n   ```\n   –î–æ–ª–∂–µ–Ω –≤–µ—Ä–Ω—É—Ç—å: `ü§ñ Telegram AI Image Generation Bot is running`\n\n3. –ë–æ—Ç –æ—Ç–≤–µ—á–∞–µ—Ç –≤ Telegram:\n   - –û—Ç–∫—Ä–æ–π—Ç–µ –≤–∞—à–µ–≥–æ –±–æ—Ç–∞ –≤ Telegram\n   - –û—Ç–ø—Ä–∞–≤—å—Ç–µ `/start`\n   - –ë–æ—Ç –¥–æ–ª–∂–µ–Ω –æ—Ç–≤–µ—Ç–∏—Ç—å –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º\n\n### Troubleshooting\n\n#### Deployment –Ω–µ –ø—Ä–æ—Ö–æ–¥–∏—Ç health check\n\n**–ü—Ä–æ–±–ª–µ–º–∞**: Deployment –ø–∞–¥–∞–µ—Ç —Å –æ—à–∏–±–∫–æ–π health check timeout\n\n**–†–µ—à–µ–Ω–∏–µ**:\n1. –£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ —Å–ª—É—à–∞–µ—Ç –Ω–∞ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –ø–æ—Ä—Ç—É (–æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è —á–µ—Ä–µ–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–∫—Ä—É–∂–µ–Ω–∏—è `PORT`)\n2. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —á—Ç–æ `/` –∏ `/health` endpoints –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã\n3. –£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ –Ω–µ—Ç –±–ª–æ–∫–∏—Ä—É—é—â–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–π –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ\n\n#### Webhook –Ω–µ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è\n\n**–ü—Ä–æ–±–ª–µ–º–∞**: –í –ª–æ–≥–∞—Ö –≤–∏–¥–Ω–æ \"REPLIT_DEV_DOMAIN not found\"\n\n**–†–µ—à–µ–Ω–∏–µ**:\n1. –£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –æ–∫—Ä—É–∂–µ–Ω–∏—è `REPLIT_DEV_DOMAIN` –¥–æ—Å—Ç—É–ø–Ω–∞\n2. –ò–ª–∏ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ `USE_WEBHOOK=False` –¥–ª—è –æ—Ç–∫–ª—é—á–µ–Ω–∏—è webhook —Ä–µ–∂–∏–º–∞\n\n#### –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç—Å—è\n\n**–ü—Ä–æ–±–ª–µ–º–∞**: –û—à–∏–±–∫–∞ \"Database initialization error\"\n\n**–†–µ—à–µ–Ω–∏–µ**:\n1. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —á—Ç–æ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è `data/` —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ –¥–æ—Å—Ç—É–ø–Ω–∞ –¥–ª—è –∑–∞–ø–∏—Å–∏\n2. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —á—Ç–æ SQLite –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –≤ deployment –æ–∫—Ä—É–∂–µ–Ω–∏–∏\n3. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏ –¥–ª—è –¥–µ—Ç–∞–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –æ—à–∏–±–∫–µ\n\n### –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ\n\nAutoscale deployment –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç:\n- **–ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ –Ω–∞–≥—Ä—É–∑–∫–µ** - –æ—Ç 0 –¥–æ N –∏–Ω—Å—Ç–∞–Ω—Å–æ–≤\n- **–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫** –ø—Ä–∏ —Å–±–æ—è—Ö\n- **Persistent storage** –¥–ª—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö\n- **–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –∑–∞—Ç—Ä–∞—Ç** - –ø–ª–∞—Ç–∏—Ç–µ —Ç–æ–ª—å–∫–æ –∑–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–µ —Ä–µ—Å—É—Ä—Å—ã\n\n### –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥\n\n–ü–æ—Å–ª–µ deployment –≤—ã –º–æ–∂–µ—Ç–µ –º–æ–Ω–∏—Ç–æ—Ä–∏—Ç—å:\n\n1. **–õ–æ–≥–∏** - –≤ Replit deployment console\n2. **–ú–µ—Ç—Ä–∏–∫–∏** - –≤ Replit deployment dashboard\n3. **Health** - —á–µ—Ä–µ–∑ `/health` endpoint\n\n### –í–∞–∂–Ω—ã–µ –∑–∞–º–µ—á–∞–Ω–∏—è\n\n1. **Webhook URL** –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç—Å—è –ø—Ä–∏ deployment\n2. **–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö SQLite** —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –º–µ–∂–¥—É –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–º–∏\n3. **–°–µ–∫—Ä–µ—Ç—ã** –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ–¥–∞—é—Ç—Å—è –∏–∑ Replit Secrets\n4. **–ü–æ—Ä—Ç** –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è —á–µ—Ä–µ–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é `PORT`\n\n### –°—Ç–æ–∏–º–æ—Å—Ç—å\n\nVM deployment –Ω–∞ Replit –∏–º–µ–µ—Ç —Å–ª–µ–¥—É—é—â–∏–µ —Ç–∞—Ä–∏—Ñ—ã:\n- –ë–∞–∑–æ–≤—ã–π –ø–ª–∞–Ω –≤–∫–ª—é—á–∞–µ—Ç –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —á–∞—Å–æ–≤\n- –î–ª—è –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–π —Ä–∞–±–æ—Ç—ã 24/7 —Ç—Ä–µ–±—É–µ—Ç—Å—è –ø–ª–∞—Ç–Ω—ã–π –ø–ª–∞–Ω\n\n–ü–æ–¥—Ä–æ–±–Ω–µ–µ –æ —Ü–µ–Ω–∞—Ö: https://replit.com/pricing\n\n### –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ä–µ—Å—É—Ä—Å—ã\n\n- [Replit Deployments Documentation](https://docs.replit.com/deployments)\n- [Health Checks Best Practices](https://docs.replit.com/deployments/health-checks)\n","size_bytes":5749},"app/states.py":{"content":"from aiogram.fsm.state import State, StatesGroup\n\n\nclass GenerationStates(StatesGroup):\n    choosing_style = State()\n    waiting_for_photo = State()\n\n\nclass CardPaymentStates(StatesGroup):\n    selecting_card_type = State()\n    selecting_package = State()\n    waiting_receipt = State()\n","size_bytes":285},"app/handlers/start.py":{"content":"from aiogram import Router, F\nfrom aiogram.filters import CommandStart, Command\nfrom aiogram.types import Message, CallbackQuery\nfrom app.database import async_session_maker\nfrom app.repositories import UserRepository\nfrom app.keyboards.inline import back_to_main_keyboard\nfrom app.keyboards.reply import main_menu_keyboard, BUTTON_BALANCE, BUTTON_HELP\nfrom app.config import settings\nimport logging\n\nlogger = logging.getLogger(__name__)\nrouter = Router()\n\n\ndef is_admin(chat_id: int) -> bool:\n    \"\"\"Check if user is admin\"\"\"\n    admin_ids = [int(admin_id) for admin_id in settings.ADMINS.split(\",\") if admin_id.strip()]\n    return chat_id in admin_ids\n\n\n@router.message(CommandStart())\nasync def cmd_start(message: Message):\n    \"\"\"Handle /start command\"\"\"\n    try:\n        logger.info(f\"=== START command from user {message.from_user.id} ===\")\n        args = message.text.split()\n        referrer_chat_id = None\n        \n        if len(args) > 1 and args[1].startswith(\"ref_\"):\n            try:\n                referrer_chat_id = int(args[1].split(\"_\")[1])\n                logger.info(f\"Referrer: {referrer_chat_id}\")\n            except Exception as e:\n                logger.error(f\"Failed to parse referrer: {e}\")\n        \n        logger.info(\"Creating database session...\")\n        async with async_session_maker() as session:\n            user_repo = UserRepository(session)\n            logger.info(\"Getting or creating user...\")\n            user = await user_repo.get_or_create(\n                chat_id=message.from_user.id,\n                username=message.from_user.username,\n                referrer_chat_id=referrer_chat_id\n            )\n            logger.info(f\"User loaded: {user.chat_id}, balance: {user.balance}\")\n        \n        logger.info(\"Building welcome text...\")\n        welcome_text = (\n            f\"üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, {message.from_user.first_name}!\\n\\n\"\n            \"üé® –Ø –±–æ—Ç –¥–ª—è AI-–≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π\\n\\n\"\n            \"üí° –ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å:\\n\"\n            \"1Ô∏è‚É£ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –º–Ω–µ —Ñ–æ—Ç–æ\\n\"\n            \"2Ô∏è –Ø –æ–±—Ä–∞–±–æ—Ç–∞—é –µ–≥–æ —á–µ—Ä–µ–∑ AI\\n\"\n            \"3Ô∏è‚É£ –ü–æ–ª—É—á–∏—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç —á–µ—Ä–µ–∑ 30-90 —Å–µ–∫—É–Ω–¥\\n\\n\"\n            f\"üí∞ –í–∞—à –±–∞–ª–∞–Ω—Å: {user.balance} —Ç–æ–∫–µ–Ω–æ–≤\\n\"\n            \"üíµ –°—Ç–æ–∏–º–æ—Å—Ç—å: 1 —Ç–æ–∫–µ–Ω = 1 –≥–µ–Ω–µ—Ä–∞—Ü–∏—è\\n\\n\"\n            \"–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –º–µ–Ω—é –Ω–∏–∂–µ –¥–ª—è –ø–æ–∫—É–ø–∫–∏ —Ç–æ–∫–µ–Ω–æ–≤ –∏–ª–∏ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –ø—Ä–æ—Ñ–∏–ª—è üëá\"\n        )\n        \n        if referrer_chat_id:\n            welcome_text += f\"\\n\\nüéÅ –í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –ø–æ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–æ–π —Å—Å—ã–ª–∫–µ! –ü–æ–ª—É—á–∏—Ç–µ +{settings.referral_bonus} —Ç–æ–∫–µ–Ω–æ–≤ –ø—Ä–∏ –ø–µ—Ä–≤–æ–π –ø–æ–∫—É–ø–∫–µ!\"\n        \n        logger.info(f\"Checking admin status for {message.from_user.id}...\")\n        admin_status = is_admin(message.from_user.id)\n        logger.info(f\"Admin status: {admin_status}\")\n        \n        logger.info(\"Building keyboard...\")\n        keyboard = main_menu_keyboard(is_admin=admin_status)\n        logger.info(f\"Keyboard created: {keyboard}\")\n        \n        logger.info(f\"Sending message to {message.from_user.id}...\")\n        await message.answer(welcome_text, reply_markup=keyboard)\n        logger.info(f\"=== Message sent successfully to {message.from_user.id} ===\")\n    except Exception as e:\n        logger.error(f\"!!! ERROR in cmd_start: {e} !!!\", exc_info=True)\n        try:\n            await message.answer(\"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.\")\n        except:\n            pass\n\n\n@router.callback_query(F.data == \"main_menu\")\nasync def show_main_menu(callback: CallbackQuery):\n    \"\"\"Show main menu (callback from inline buttons)\"\"\"\n    async with async_session_maker() as session:\n        user_repo = UserRepository(session)\n        user = await user_repo.get_by_chat_id(callback.from_user.id)\n    \n    text = (\n        \"üì± –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\\n\\n\"\n        f\"üí∞ –ë–∞–ª–∞–Ω—Å: {user.balance if user else 0} —Ç–æ–∫–µ–Ω–æ–≤\\n\\n\"\n        \"–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é –Ω–∏–∂–µ ‚¨áÔ∏è\"\n    )\n    \n    await callback.message.edit_text(text)\n    await callback.answer()\n\n\n@router.callback_query(F.data == \"start_generation\")\nasync def start_generation_menu(callback: CallbackQuery):\n    \"\"\"Show generation start menu\"\"\"\n    from app.keyboards.inline import generation_styles_keyboard\n    \n    text = (\n        \"üé® –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π\\n\\n\"\n        \"üì∏ –í—ã–±–µ—Ä–∏—Ç–µ —Å—Ç–∏–ª—å, –∑–∞—Ç–µ–º –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ\\n\"\n        \"üí∞ –°—Ç–æ–∏–º–æ—Å—Ç—å: 1 —Ç–æ–∫–µ–Ω = 1 –≥–µ–Ω–µ—Ä–∞—Ü–∏—è\\n\\n\"\n        \"–í—ã–±–µ—Ä–∏—Ç–µ —Å—Ç–∏–ª—å:\"\n    )\n    \n    await callback.message.edit_text(text, reply_markup=generation_styles_keyboard())\n    await callback.answer()\n\n\n@router.message(F.text == BUTTON_BALANCE)\nasync def show_profile_message(message: Message):\n    \"\"\"Show user profile (from reply keyboard button)\"\"\"\n    async with async_session_maker() as session:\n        user_repo = UserRepository(session)\n        user = await user_repo.get_by_chat_id(message.from_user.id)\n    \n    if not user:\n        await message.answer(\"–û—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω\")\n        return\n    \n    text = (\n        \"üíé –í–∞—à –ø—Ä–æ—Ñ–∏–ª—å\\n\\n\"\n        f\"üÜî ID: {message.from_user.id}\\n\"\n        f\"üë§ –ò–º—è: {message.from_user.full_name}\\n\"\n        f\"üí∞ –ë–∞–ª–∞–Ω—Å: {user.balance} —Ç–æ–∫–µ–Ω–æ–≤\\n\"\n        f\"üìÖ –î–∞—Ç–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏: {user.created_at.strftime('%d.%m.%Y')}\\n\"\n    )\n    \n    await message.answer(text)\n\n\n@router.callback_query(F.data == \"profile\")\nasync def show_profile_callback(callback: CallbackQuery):\n    \"\"\"Show user profile (from inline button - legacy)\"\"\"\n    async with async_session_maker() as session:\n        user_repo = UserRepository(session)\n        user = await user_repo.get_by_chat_id(callback.from_user.id)\n    \n    if not user:\n        await callback.answer(\"–û—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω\", show_alert=True)\n        return\n    \n    text = (\n        \"üë§ –í–∞—à –ø—Ä–æ—Ñ–∏–ª—å\\n\\n\"\n        f\"üÜî ID: {callback.from_user.id}\\n\"\n        f\"üë§ –ò–º—è: {callback.from_user.full_name}\\n\"\n        f\"üí∞ –ë–∞–ª–∞–Ω—Å: {user.balance} —Ç–æ–∫–µ–Ω–æ–≤\\n\"\n        f\"üìÖ –î–∞—Ç–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏: {user.created_at.strftime('%d.%m.%Y')}\\n\"\n    )\n    \n    await callback.message.edit_text(text, reply_markup=back_to_main_keyboard())\n    await callback.answer()\n\n\n@router.message(F.text == BUTTON_HELP)\nasync def show_help_message(message: Message):\n    \"\"\"Show help information (from reply keyboard button)\"\"\"\n    text = (\n        \"‚ÑπÔ∏è –ü–æ–º–æ—â—å\\n\\n\"\n        \"üé® –ö–∞–∫ –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:\\n\"\n        \"1. –ù–∞–∂–º–∏—Ç–µ 'üé® –ì–µ–Ω–µ—Ä–∞—Ü–∏—è'\\n\"\n        \"2. –í—ã–±–µ—Ä–∏—Ç–µ —Å—Ç–∏–ª—å\\n\"\n        \"3. –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ\\n\"\n        \"4. –†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–∏–¥–µ—Ç —á–µ—Ä–µ–∑ 30-90 —Å–µ–∫—É–Ω–¥\\n\\n\"\n        \"üí∞ –°—Ç–æ–∏–º–æ—Å—Ç—å:\\n\"\n        \"‚Ä¢ 1 –≥–µ–Ω–µ—Ä–∞—Ü–∏—è = 1 —Ç–æ–∫–µ–Ω\\n\"\n        \"‚Ä¢ –¢–æ–∫–µ–Ω—ã –ø–æ–∫—É–ø–∞—é—Ç—Å—è –ø–∞–∫–µ—Ç–∞–º–∏\\n\\n\"\n        \"üí≥ –°–ø–æ—Å–æ–±—ã –æ–ø–ª–∞—Ç—ã:\\n\"\n        \"‚Ä¢ Telegram Stars (‚≠êÔ∏è)\\n\"\n        \"‚Ä¢ –ö—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–∞ (USDT, TON, BTC)\\n\"\n        \"‚Ä¢ –ë–∞–Ω–∫–æ–≤—Å–∫–∞—è –∫–∞—Ä—Ç–∞ (RU/INTL)\\n\\n\"\n        \"üîó –†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è –ø—Ä–æ–≥—Ä–∞–º–º–∞:\\n\"\n        \"‚Ä¢ –ü—Ä–∏–≥–ª–∞—à–∞–π—Ç–µ –¥—Ä—É–∑–µ–π\\n\"\n        f\"‚Ä¢ –ü–æ–ª—É—á–∞–π—Ç–µ {settings.referral_commission}% —Å –∏—Ö –ø–æ–∫—É–ø–æ–∫\\n\"\n        f\"‚Ä¢ –í–∞—à–∏ —Ä–µ—Ñ–µ—Ä–∞–ª—ã –ø–æ–ª—É—á–∞—é—Ç +{settings.referral_bonus} —Ç–æ–∫–µ–Ω–æ–≤\\n\\n\"\n        \"üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞: @your_support\"\n    )\n    \n    await message.answer(text)\n\n\n@router.callback_query(F.data == \"help\")\nasync def show_help_callback(callback: CallbackQuery):\n    \"\"\"Show help information (from inline button - legacy)\"\"\"\n    text = (\n        \"‚ÑπÔ∏è –ü–æ–º–æ—â—å\\n\\n\"\n        \"üé® –ö–∞–∫ –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:\\n\"\n        \"1. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –±–æ—Ç—É –ª—é–±–æ–µ —Ñ–æ—Ç–æ\\n\"\n        \"2. –ë–æ—Ç –æ–±—Ä–∞–±–æ—Ç–∞–µ—Ç –µ–≥–æ —á–µ—Ä–µ–∑ AI\\n\"\n        \"3. –†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–∏–¥–µ—Ç —á–µ—Ä–µ–∑ 30-90 —Å–µ–∫—É–Ω–¥\\n\\n\"\n        \"üí∞ –°—Ç–æ–∏–º–æ—Å—Ç—å:\\n\"\n        \"‚Ä¢ 1 –≥–µ–Ω–µ—Ä–∞—Ü–∏—è = 1 —Ç–æ–∫–µ–Ω\\n\"\n        \"‚Ä¢ –¢–æ–∫–µ–Ω—ã –ø–æ–∫—É–ø–∞—é—Ç—Å—è –ø–∞–∫–µ—Ç–∞–º–∏\\n\\n\"\n        \"üí≥ –°–ø–æ—Å–æ–±—ã –æ–ø–ª–∞—Ç—ã:\\n\"\n        \"‚Ä¢ Telegram Stars (‚≠êÔ∏è)\\n\"\n        \"‚Ä¢ –ö—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–∞ (USDT, TON, BTC)\\n\\n\"\n        \"üîó –†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è –ø—Ä–æ–≥—Ä–∞–º–º–∞:\\n\"\n        \"‚Ä¢ –ü—Ä–∏–≥–ª–∞—à–∞–π—Ç–µ –¥—Ä—É–∑–µ–π\\n\"\n        f\"‚Ä¢ –ü–æ–ª—É—á–∞–π—Ç–µ {settings.referral_commission}% —Å –∏—Ö –ø–æ–∫—É–ø–æ–∫\\n\"\n        f\"‚Ä¢ –í–∞—à–∏ —Ä–µ—Ñ–µ—Ä–∞–ª—ã –ø–æ–ª—É—á–∞—é—Ç +{settings.referral_bonus} —Ç–æ–∫–µ–Ω–æ–≤\\n\\n\"\n        \"üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞: @your_support\"\n    )\n    \n    await callback.message.edit_text(text, reply_markup=back_to_main_keyboard())\n    await callback.answer()\n","size_bytes":9079},"app/services/billing.py":{"content":"from app.config import settings\nfrom typing import Optional, Dict\n\n\nclass BillingService:\n    \"\"\"Service for price calculations and token packages\"\"\"\n    \n    @staticmethod\n    def get_stars_package(tokens: int) -> Optional[Dict]:\n        \"\"\"Get Stars package info by token amount\"\"\"\n        packages = settings.stars_packs_list\n        for pack in packages:\n            if pack.get(\"tokens\") == tokens:\n                return pack\n        return None\n    \n    @staticmethod\n    def get_all_packages() -> list:\n        \"\"\"Get all available Stars packages\"\"\"\n        return settings.stars_packs_list\n    \n    @staticmethod\n    def calculate_discount(tokens: int) -> int:\n        \"\"\"Calculate discount percentage for token amount\"\"\"\n        pack = BillingService.get_stars_package(tokens)\n        return pack.get(\"discount\", 0) if pack else 0\n    \n    @staticmethod\n    def calculate_referral_bonus(amount: int) -> int:\n        \"\"\"Calculate referral commission from purchase\"\"\"\n        return int(amount * settings.referral_commission / 100)\n","size_bytes":1040},"README.md":{"content":"# Telegram Bot –¥–ª—è AI-–≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π\n\n–ü–æ–ª–Ω–æ—Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π Telegram-–±–æ—Ç –Ω–∞ Python –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π —á–µ—Ä–µ–∑ Clothoff.net API —Å —Å–∏—Å—Ç–µ–º–æ–π –º–æ–Ω–µ—Ç–∏–∑–∞—Ü–∏–∏, —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–æ–π –ø—Ä–æ–≥—Ä–∞–º–º–æ–π –∏ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å—é.\n\n## –§—É–Ω–∫—Ü–∏–∏\n\n### –î–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:\n- ü§ñ –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —á–µ—Ä–µ–∑ –∫–æ–º–∞–Ω–¥—É `/start`\n- üé® –ì–µ–Ω–µ—Ä–∞—Ü–∏—è AI-–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π (–æ—Ç–ø—Ä–∞–≤—å —Ñ–æ—Ç–æ –±–æ—Ç—É)\n- üí∞ –ü–æ–∫—É–ø–∫–∞ —Ç–æ–∫–µ–Ω–æ–≤ —á–µ—Ä–µ–∑ Telegram Stars –∏–ª–∏ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—É (USDT/TON/BTC)\n- üéÅ –†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ —Å –±–æ–Ω—É—Å–∞–º–∏ (+2 —Ç–æ–∫–µ–Ω–∞ –ø—Ä–∏ –ø–µ—Ä–≤–æ–π –ø–æ–∫—É–ø–∫–µ –ø–æ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–æ–π —Å—Å—ã–ª–∫–µ)\n- üíµ 10% –∫–æ–º–∏—Å—Å–∏—è —Å –ø–æ–∫—É–ø–æ–∫ —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤\n- üìä –ü—Ä–æ—Å–º–æ—Ç—Ä –±–∞–ª–∞–Ω—Å–∞ –∏ –∏—Å—Ç–æ—Ä–∏–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π\n\n### –î–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤:\n- üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º\n- üí≥ –ù–∞—á–∏—Å–ª–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–æ–≤\n- üîç –ü—Ä–æ—Å–º–æ—Ç—Ä –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è—Ö\n- üìß –†–∞—Å—Å—ã–ª–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º\n\n## –¢–µ—Ö–Ω–æ–ª–æ–≥–∏–∏\n\n- **Python 3.11** - –æ—Å–Ω–æ–≤–Ω–æ–π —è–∑—ã–∫\n- **aiogram 3.13** - —Ñ—Ä–µ–π–º–≤–æ—Ä–∫ –¥–ª—è Telegram Bot API\n- **SQLAlchemy** - ORM –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö\n- **SQLite** - –±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö\n- **aiohttp** - –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π HTTP-–∫–ª–∏–µ–Ω—Ç\n- **Webhook-–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞** - –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π –æ—Ç Telegram\n\n## –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∏ –∑–∞–ø—É—Å–∫\n\n### –ù–∞ Replit (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è)\n\n1. –ù–∞—Å—Ç—Ä–æ–π—Ç–µ —Å–µ–∫—Ä–µ—Ç—ã –≤ Replit Secrets:\n   - `BOT_TOKEN` - —Ç–æ–∫–µ–Ω –≤–∞—à–µ–≥–æ –±–æ—Ç–∞ –æ—Ç @BotFather\n   - `IMAGE_API_TOKEN` - —Ç–æ–∫–µ–Ω API Clothoff.net\n   - `IMAGE_API_URL` - URL API Clothoff.net\n   - `CRYPTO_BOT_TOKEN` - —Ç–æ–∫–µ–Ω CryptoBot –¥–ª—è –ø—Ä–∏–µ–º–∞ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—ã\n   - `WEBHOOK_SECRET` - —Å–ª—É—á–∞–π–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ webhook\n   - `SESSION_SECRET` - —Å–µ–∫—Ä–µ—Ç –¥–ª—è —Å–µ—Å—Å–∏–π (–≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏)\n   - `ADMINS` - chat_id –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é (–Ω–∞–ø—Ä–∏–º–µ—Ä: `123456789,987654321`)\n\n2. **–î–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏**: –ù–∞–∂–º–∏—Ç–µ \"Run\" - –±–æ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–ø—É—Å—Ç–∏—Ç—Å—è –∏ –Ω–∞—Å—Ç—Ä–æ–∏—Ç webhook\n\n3. **–î–ª—è production**: –ù–∞–∂–º–∏—Ç–µ \"Deploy\" –¥–ª—è –¥–µ–ø–ª–æ—è –Ω–∞ Replit VM (—Å–º. [DEPLOYMENT.md](DEPLOYMENT.md))\n\n4. –ù–∞–π–¥–∏—Ç–µ –≤–∞—à–µ–≥–æ –±–æ—Ç–∞ –≤ Telegram –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ `/start`\n\n### –õ–æ–∫–∞–ª—å–Ω—ã–π –∑–∞–ø—É—Å–∫\n\n```bash\n# –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏\npip install -r requirements.txt\n\n# –°–æ–∑–¥–∞–π—Ç–µ .env —Ñ–∞–π–ª —Å —Å–µ–∫—Ä–µ—Ç–∞–º–∏\ncp .env.example .env\n# –û—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä—É–π—Ç–µ .env\n\n# –ó–∞–ø—É—Å—Ç–∏—Ç–µ –±–æ—Ç–∞\npython main.py\n```\n\n## –ö–æ–º–∞–Ω–¥—ã –±–æ—Ç–∞\n\n- `/start` - –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∏ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\n- `/buy` - –ö—É–ø–∏—Ç—å —Ç–æ–∫–µ–Ω—ã\n- `/ref` - –ü–æ–ª—É—á–∏—Ç—å —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω—É—é —Å—Å—ã–ª–∫—É\n- `/balance` - –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±–∞–ª–∞–Ω—Å\n- `/history` - –ò—Å—Ç–æ—Ä–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π\n- `/admin` - –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å (—Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤)\n\n## –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞\n\n```\n‚îú‚îÄ‚îÄ main.py                      # –¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞, webhook-—Å–µ—Ä–≤–µ—Ä\n‚îú‚îÄ‚îÄ app/\n‚îÇ   ‚îú‚îÄ‚îÄ config.py               # –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è\n‚îÇ   ‚îú‚îÄ‚îÄ database.py             # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ë–î\n‚îÇ   ‚îú‚îÄ‚îÄ models.py               # –ú–æ–¥–µ–ª–∏ SQLAlchemy\n‚îÇ   ‚îú‚îÄ‚îÄ repositories.py         # –†–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –ë–î\n‚îÇ   ‚îú‚îÄ‚îÄ handlers/               # –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ start.py           # /start, –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ generate.py        # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ payment.py         # –ü–æ–∫—É–ø–∫–∞ —Ç–æ–∫–µ–Ω–æ–≤\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ referral.py        # –†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ admin.py           # –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å\n‚îÇ   ‚îú‚îÄ‚îÄ services/               # –ë–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∞\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ image_api.py       # –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Image API\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ crypto_payment.py  # –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å CryptoBot\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ billing.py         # –ë–∏–ª–ª–∏–Ω–≥\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ referral.py        # –†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞\n‚îÇ   ‚îú‚îÄ‚îÄ keyboards/              # –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ inline.py          # Inline-–∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã\n‚îÇ   ‚îî‚îÄ‚îÄ middlewares/            # Middleware\n‚îÇ       ‚îî‚îÄ‚îÄ admin.py           # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∞\n‚îú‚îÄ‚îÄ data/                       # –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö\n‚îÇ   ‚îî‚îÄ‚îÄ bot.db                 # SQLite –ë–î\n‚îî‚îÄ‚îÄ requirements.txt            # –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏\n```\n\n## –ü–∞–∫–µ—Ç—ã —Ç–æ–∫–µ–Ω–æ–≤\n\n| –¢–æ–∫–µ–Ω—ã | –¶–µ–Ω–∞ (Stars) | –¶–µ–Ω–∞ (USDT) |\n|--------|--------------|-------------|\n| 10     | 100          | $5          |\n| 25     | 230          | $11         |\n| 50     | 450          | $21         |\n| 100    | 850          | $40         |\n| 200    | 1600         | $75         |\n\n## –†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞\n\n- –ü–æ–ª—É—á–∏—Ç–µ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω—É—é —Å—Å—ã–ª–∫—É —á–µ—Ä–µ–∑ `/ref`\n- –ü—Ä–∏–≥–ª–∞—à–∞–π—Ç–µ –¥—Ä—É–∑–µ–π –ø–æ —Å–≤–æ–µ–π —Å—Å—ã–ª–∫–µ\n- –î—Ä—É–≥ –ø–æ–ª—É—á–∏—Ç +2 —Ç–æ–∫–µ–Ω–∞ –ø—Ä–∏ –ø–µ—Ä–≤–æ–π –ø–æ–∫—É–ø–∫–µ\n- –í—ã –ø–æ–ª—É—á–∏—Ç–µ 10% –æ—Ç —Å—É–º–º—ã –µ–≥–æ –ø–æ–∫—É–ø–æ–∫ –≤ —Ç–æ–∫–µ–Ω–∞—Ö\n\n## Endpoints\n\n- `/` - –ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ (—Å—Ç–∞—Ç—É—Å –±–æ—Ç–∞)\n- `/health` - Health check\n- `/webhook/telegram` - Webhook –¥–ª—è Telegram Bot API\n- `/webhook/image_generation` - Webhook –¥–ª—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏\n\n## –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö\n\n### –¢–∞–±–ª–∏—Ü—ã:\n\n- **users** - –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ (chat_id, username, balance, is_admin, referrer_id)\n- **transactions** - –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ (user_id, amount, type, payment_method)\n- **referrals** - –†–µ—Ñ–µ—Ä–∞–ª—ã (referrer_id, referred_id, bonus_earned)\n- **generation_tasks** - –ó–∞–¥–∞—á–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ (user_id, task_id, status, result_url)\n\n## –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å\n\n- –í—Å–µ API-–∫–ª—é—á–∏ —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è\n- Webhook –∑–∞—â–∏—â–µ–Ω —Å–µ–∫—Ä–µ—Ç–Ω—ã–º —Ç–æ–∫–µ–Ω–æ–º\n- –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–∞\n- –¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –∏–º–µ—é—Ç –¥–æ—Å—Ç—É–ø –∫ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏\n\n## –õ–∏—Ü–µ–Ω–∑–∏—è\n\nMIT\n\n## –ü–æ–¥–¥–µ—Ä–∂–∫–∞\n\n–ï—Å–ª–∏ —É –≤–∞—Å –≤–æ–∑–Ω–∏–∫–ª–∏ –≤–æ–ø—Ä–æ—Å—ã –∏–ª–∏ –ø—Ä–æ–±–ª–µ–º—ã, —Å–æ–∑–¥–∞–π—Ç–µ issue –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏.\n","size_bytes":6919},"app/handlers/generate.py":{"content":"from aiogram import Router, F\nfrom aiogram.types import Message, CallbackQuery\nfrom aiogram.fsm.context import FSMContext\nfrom app.database import async_session_maker\nfrom app.repositories import UserRepository, GenerationTaskRepository, TransactionRepository\nfrom app.services.image_api import ImageGenerationAPI\nfrom app.keyboards.inline import back_to_main_keyboard, buy_tokens_keyboard, generation_styles_keyboard, video_models_keyboard\nfrom app.keyboards.reply import BUTTON_PHOTO, BUTTON_VIDEO\nfrom app.states import GenerationStates, CardPaymentStates\nimport uuid\nimport os\nimport logging\n\nlogger = logging.getLogger(__name__)\nrouter = Router()\n\n\n@router.message(F.text == BUTTON_PHOTO)\nasync def start_photo_generation(message: Message, state: FSMContext):\n    \"\"\"Handle photo generation button from reply keyboard\"\"\"\n    await state.clear()\n    await state.update_data(content_type=\"photo\")\n    \n    text = (\n        \"üì∏ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ñ–æ—Ç–æ\\n\\n\"\n        \"–í—ã–±–µ—Ä–∏—Ç–µ —Å—Ç–∏–ª—å, –∑–∞—Ç–µ–º –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ\\n\"\n        \"üí∞ –°—Ç–æ–∏–º–æ—Å—Ç—å: 1 —Ç–æ–∫–µ–Ω = 1 –≥–µ–Ω–µ—Ä–∞—Ü–∏—è\\n\\n\"\n        \"–í—ã–±–µ—Ä–∏—Ç–µ —Å—Ç–∏–ª—å:\"\n    )\n    \n    await message.answer(text, reply_markup=generation_styles_keyboard())\n\n\n@router.message(F.text == BUTTON_VIDEO)\nasync def start_video_generation(message: Message, state: FSMContext):\n    \"\"\"Handle video generation button - generates VIDEO from PHOTO\"\"\"\n    await state.clear()\n    await state.update_data(content_type=\"video\")\n    \n    text = (\n        \"üé¨ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–∏–¥–µ–æ –∏–∑ —Ñ–æ—Ç–æ\\n\\n\"\n        \"üì∏ –í—ã–±–µ—Ä–∏—Ç–µ –∞–Ω–∏–º–∞—Ü–∏—é, –∑–∞—Ç–µ–º –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –§–û–¢–û\\n\"\n        \"üé• –ù–∞ –≤—ã—Ö–æ–¥–µ –ø–æ–ª—É—á–∏—Ç–µ –≤–∏–¥–µ–æ —Å –∞–Ω–∏–º–∞—Ü–∏–µ–π\\n\\n\"\n        \"üí∞ –°—Ç–æ–∏–º–æ—Å—Ç—å: 1 —Ç–æ–∫–µ–Ω = 1 –≥–µ–Ω–µ—Ä–∞—Ü–∏—è\\n\"\n        \"‚è± –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–Ω–∏–º–∞–µ—Ç 60-120 —Å–µ–∫—É–Ω–¥\\n\\n\"\n        \"–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –∞–Ω–∏–º–∞—Ü–∏–∏:\"\n    )\n    \n    await message.answer(text, reply_markup=video_models_keyboard())\n\n\n@router.callback_query(F.data.startswith(\"style_\"))\nasync def select_style(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Select photo undress style\"\"\"\n    style = callback.data.split(\"_\")[1]\n    await state.update_data(style=style, generation_type=\"photo\")\n    await state.set_state(GenerationStates.waiting_for_photo)\n    \n    style_names = {\n        \"1\": \"üëó –°—Ç–∏–ª—å 1\",\n        \"2\": \"üíÉ –°—Ç–∏–ª—å 2\",\n        \"3\": \"üëô –°—Ç–∏–ª—å 3\",\n        \"4\": \"üî• –°—Ç–∏–ª—å 4\",\n        \"5\": \"‚ú® –°—Ç–∏–ª—å 5\"\n    }\n    \n    text = (\n        f\"‚úÖ –í—ã–±—Ä–∞–Ω —Å—Ç–∏–ª—å: {style_names.get(style, '–°—Ç–∏–ª—å ' + style)}\\n\\n\"\n        \"üì∏ –¢–µ–ø–µ—Ä—å –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏\\n\\n\"\n        \"üí∞ –°—Ç–æ–∏–º–æ—Å—Ç—å: 1 —Ç–æ–∫–µ–Ω\"\n    )\n    \n    await callback.message.edit_text(text, reply_markup=back_to_main_keyboard())\n    await callback.answer(\"–°—Ç–∏–ª—å –≤—ã–±—Ä–∞–Ω! –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ\")\n\n\n@router.callback_query(F.data.startswith(\"video_model_\"))\nasync def select_video_model(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Select video animation model\"\"\"\n    model_id = callback.data.replace(\"video_model_\", \"\")\n    await state.update_data(video_model=model_id, generation_type=\"video\")\n    await state.set_state(GenerationStates.waiting_for_photo)\n    \n    text = (\n        f\"‚úÖ –ê–Ω–∏–º–∞—Ü–∏—è –≤—ã–±—Ä–∞–Ω–∞!\\n\\n\"\n        \"üì∏ –¢–µ–ø–µ—Ä—å –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –§–û–¢–û —á–µ–ª–æ–≤–µ–∫–∞\\n\"\n        \"üé• –ù–∞ –≤—ã—Ö–æ–¥–µ –ø–æ–ª—É—á–∏—Ç–µ –≤–∏–¥–µ–æ —Å –∞–Ω–∏–º–∞—Ü–∏–µ–π\\n\\n\"\n        \"üí∞ –°—Ç–æ–∏–º–æ—Å—Ç—å: 1 —Ç–æ–∫–µ–Ω\"\n    )\n    \n    await callback.message.edit_text(text, reply_markup=back_to_main_keyboard())\n    await callback.answer(\"–ú–æ–¥–µ–ª—å –≤—ã–±—Ä–∞–Ω–∞! –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ\")\n\n\n@router.message(GenerationStates.waiting_for_photo, F.photo)\nasync def handle_photo_with_style(message: Message, state: FSMContext):\n    \"\"\"Handle photo - for both photo undress and video generation\"\"\"\n    data = await state.get_data()\n    generation_type = data.get(\"generation_type\", \"photo\")\n    style = data.get(\"style\", \"1\")\n    video_model = data.get(\"video_model\")\n    \n    async with async_session_maker() as session:\n        user_repo = UserRepository(session)\n        user = await user_repo.get_by_chat_id(message.from_user.id)\n        \n        if not user:\n            await message.answer(\"‚ùå –û—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start\")\n            await state.clear()\n            return\n        \n        if user.balance < 1:\n            await message.answer(\n                \"‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ç–æ–∫–µ–Ω–æ–≤!\\n\\n\"\n                f\"üí∞ –í–∞—à –±–∞–ª–∞–Ω—Å: {user.balance} —Ç–æ–∫–µ–Ω–æ–≤\\n\"\n                \"üíµ –°—Ç–æ–∏–º–æ—Å—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: 1 —Ç–æ–∫–µ–Ω\\n\\n\"\n                \"–ö—É–ø–∏—Ç–µ —Ç–æ–∫–µ–Ω—ã —á–µ—Ä–µ–∑ –º–µ–Ω—é /start\",\n                reply_markup=buy_tokens_keyboard()\n            )\n            await state.clear()\n            return\n        \n        photo = message.photo[-1]\n        file = await message.bot.get_file(photo.file_id)\n        file_data = await message.bot.download_file(file.file_path)\n        photo_bytes = file_data.getvalue()\n        \n        gen_id = f\"gen_{uuid.uuid4().hex[:12]}\"\n        \n        replit_domain = os.getenv(\"REPLIT_DEV_DOMAIN\")\n        if not replit_domain:\n            replit_slug = os.getenv(\"REPL_SLUG\")\n            replit_owner = os.getenv(\"REPL_OWNER\")\n            if replit_slug and replit_owner:\n                replit_domain = f\"{replit_slug}.{replit_owner}.repl.co\"\n            else:\n                replit_domain = \"localhost:8080\"\n        \n        webhook_url = f\"https://{replit_domain}/webhook/image_generation\"\n        \n        if generation_type == \"video\" and video_model:\n            progress_msg = await message.answer(\"üé¨ –°–æ–∑–¥–∞—é –≤–∏–¥–µ–æ –∏–∑ —Ñ–æ—Ç–æ...\")\n            result = await ImageGenerationAPI.generate_video(\n                image_file_data=photo_bytes,\n                webhook_url=webhook_url,\n                gen_id=gen_id,\n                model_id=video_model\n            )\n            task_desc = f\"–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–∏–¥–µ–æ\"\n            result_time = \"60-120 —Å–µ–∫—É–Ω–¥\"\n        else:\n            progress_msg = await message.answer(\"‚è≥ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é —Ñ–æ—Ç–æ...\")\n            result = await ImageGenerationAPI.generate_image(\n                photo_file_data=photo_bytes,\n                webhook_url=webhook_url,\n                gen_id=gen_id,\n                style=style\n            )\n            task_desc = f\"–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è (–°—Ç–∏–ª—å {style})\"\n            result_time = \"30-90 —Å–µ–∫—É–Ω–¥\"\n        \n        if result:\n            task_repo = GenerationTaskRepository(session)\n            await task_repo.create(\n                user_id=user.id,\n                task_id=gen_id,\n                photo_id=photo.file_id\n            )\n            \n            await user_repo.update_balance(message.from_user.id, -1)\n            \n            tx_repo = TransactionRepository(session)\n            await tx_repo.create(\n                user_id=user.id,\n                amount=-1,\n                reason=task_desc\n            )\n            \n            await progress_msg.edit_text(\n                \"‚úÖ –ó–∞–¥–∞—á–∞ —Å–æ–∑–¥–∞–Ω–∞!\\n\\n\"\n                f\"‚è± –†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–∏–¥–µ—Ç —á–µ—Ä–µ–∑ {result_time}\\n\"\n                f\"üí∞ –°–ø–∏—Å–∞–Ω–æ 1 —Ç–æ–∫–µ–Ω\\n\"\n                f\"üíµ –ù–æ–≤—ã–π –±–∞–ª–∞–Ω—Å: {user.balance - 1} —Ç–æ–∫–µ–Ω–æ–≤\"\n            )\n            \n            logger.info(f\"{task_desc} task created: {gen_id} by user {message.from_user.id}\")\n        else:\n            await progress_msg.edit_text(\n                \"‚ùå –û—à–∏–±–∫–∞ API –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∑–∞–¥–∞—á–∏\\n\\n\"\n                \"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É\"\n            )\n        \n        await state.clear()\n\n\n@router.message(F.photo)\nasync def handle_photo(message: Message, state: FSMContext):\n    \"\"\"Handle photo for AI generation\"\"\"\n    current_state = await state.get_state()\n    if current_state == CardPaymentStates.waiting_receipt:\n        return\n    \n    async with async_session_maker() as session:\n        user_repo = UserRepository(session)\n        user = await user_repo.get_by_chat_id(message.from_user.id)\n        \n        if not user:\n            await message.answer(\"‚ùå –û—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start\")\n            return\n        \n        if user.balance < 1:\n            await message.answer(\n                \"‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ç–æ–∫–µ–Ω–æ–≤!\\n\\n\"\n                f\"üí∞ –í–∞—à –±–∞–ª–∞–Ω—Å: {user.balance} —Ç–æ–∫–µ–Ω–æ–≤\\n\"\n                \"üíµ –°—Ç–æ–∏–º–æ—Å—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: 1 —Ç–æ–∫–µ–Ω\\n\\n\"\n                \"–ö—É–ø–∏—Ç–µ —Ç–æ–∫–µ–Ω—ã —á–µ—Ä–µ–∑ –º–µ–Ω—é /start\",\n                reply_markup=buy_tokens_keyboard()\n            )\n            return\n        \n        photo = message.photo[-1]\n        file = await message.bot.get_file(photo.file_id)\n        file_data = await message.bot.download_file(file.file_path)\n        \n        gen_id = f\"gen_{uuid.uuid4().hex[:12]}\"\n        \n        replit_domain = os.getenv(\"REPLIT_DEV_DOMAIN\")\n        if not replit_domain:\n            replit_slug = os.getenv(\"REPL_SLUG\")\n            replit_owner = os.getenv(\"REPL_OWNER\")\n            if replit_slug and replit_owner:\n                replit_domain = f\"{replit_slug}.{replit_owner}.repl.co\"\n            else:\n                replit_domain = \"localhost:8080\"\n        \n        webhook_url = f\"https://{replit_domain}/webhook/image_generation\"\n        \n        progress_msg = await message.answer(\"‚è≥ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é —Ñ–æ—Ç–æ...\")\n        \n        result = await ImageGenerationAPI.generate_image(\n            photo_file_data=file_data.read(),\n            webhook_url=webhook_url,\n            gen_id=gen_id\n        )\n        \n        if result:\n            task_repo = GenerationTaskRepository(session)\n            await task_repo.create(\n                user_id=user.id,\n                task_id=gen_id,\n                photo_id=photo.file_id\n            )\n            \n            await user_repo.update_balance(message.from_user.id, -1)\n            \n            tx_repo = TransactionRepository(session)\n            await tx_repo.create(\n                user_id=user.id,\n                amount=-1,\n                reason=\"–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è\"\n            )\n            \n            await progress_msg.edit_text(\n                \"‚úÖ –ó–∞–¥–∞—á–∞ —Å–æ–∑–¥–∞–Ω–∞!\\n\\n\"\n                \"‚è± –†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–∏–¥–µ—Ç —á–µ—Ä–µ–∑ 30-90 —Å–µ–∫—É–Ω–¥\\n\"\n                f\"üí∞ –°–ø–∏—Å–∞–Ω–æ 1 —Ç–æ–∫–µ–Ω\\n\"\n                f\"üíµ –ù–æ–≤—ã–π –±–∞–ª–∞–Ω—Å: {user.balance - 1} —Ç–æ–∫–µ–Ω–æ–≤\"\n            )\n            \n            logger.info(f\"Generation task created: {gen_id} by user {message.from_user.id}\")\n        else:\n            await progress_msg.edit_text(\n                \"‚ùå –û—à–∏–±–∫–∞ API –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∑–∞–¥–∞—á–∏\\n\\n\"\n                \"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É\"\n            )\n\n\n@router.message(F.video)\nasync def handle_video(message: Message, state: FSMContext):\n    \"\"\"Handle video for AI generation\"\"\"\n    current_state = await state.get_state()\n    if current_state == CardPaymentStates.waiting_receipt:\n        return\n    \n    async with async_session_maker() as session:\n        user_repo = UserRepository(session)\n        user = await user_repo.get_by_chat_id(message.from_user.id)\n        \n        if not user:\n            await message.answer(\"‚ùå –û—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start\")\n            return\n        \n        if user.balance < 1:\n            await message.answer(\n                \"‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ç–æ–∫–µ–Ω–æ–≤!\\n\\n\"\n                f\"üí∞ –í–∞—à –±–∞–ª–∞–Ω—Å: {user.balance} —Ç–æ–∫–µ–Ω–æ–≤\\n\"\n                \"üíµ –°—Ç–æ–∏–º–æ—Å—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: 1 —Ç–æ–∫–µ–Ω\\n\\n\"\n                \"–ö—É–ø–∏—Ç–µ —Ç–æ–∫–µ–Ω—ã —á–µ—Ä–µ–∑ –º–µ–Ω—é /start\",\n                reply_markup=buy_tokens_keyboard()\n            )\n            return\n        \n        video = message.video\n        file = await message.bot.get_file(video.file_id)\n        file_data = await message.bot.download_file(file.file_path)\n        \n        gen_id = f\"gen_{uuid.uuid4().hex[:12]}\"\n        \n        replit_domain = os.getenv(\"REPLIT_DEV_DOMAIN\")\n        if not replit_domain:\n            replit_slug = os.getenv(\"REPL_SLUG\")\n            replit_owner = os.getenv(\"REPL_OWNER\")\n            if replit_slug and replit_owner:\n                replit_domain = f\"{replit_slug}.{replit_owner}.repl.co\"\n            else:\n                replit_domain = \"localhost:8080\"\n        \n        webhook_url = f\"https://{replit_domain}/webhook/image_generation\"\n        \n        progress_msg = await message.answer(\"‚è≥ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –≤–∏–¥–µ–æ...\")\n        \n        result = await ImageGenerationAPI.generate_video(\n            video_file_data=file_data.read(),\n            webhook_url=webhook_url,\n            gen_id=gen_id\n        )\n        \n        if result:\n            task_repo = GenerationTaskRepository(session)\n            await task_repo.create(\n                user_id=user.id,\n                task_id=gen_id,\n                photo_id=video.file_id\n            )\n            \n            await user_repo.update_balance(message.from_user.id, -1)\n            \n            tx_repo = TransactionRepository(session)\n            await tx_repo.create(\n                user_id=user.id,\n                amount=-1,\n                reason=\"–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–∏–¥–µ–æ\"\n            )\n            \n            await progress_msg.edit_text(\n                \"‚úÖ –ó–∞–¥–∞—á–∞ —Å–æ–∑–¥–∞–Ω–∞!\\n\\n\"\n                \"‚è± –†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–∏–¥–µ—Ç —á–µ—Ä–µ–∑ 60-120 —Å–µ–∫—É–Ω–¥\\n\"\n                f\"üí∞ –°–ø–∏—Å–∞–Ω–æ 1 —Ç–æ–∫–µ–Ω\\n\"\n                f\"üíµ –ù–æ–≤—ã–π –±–∞–ª–∞–Ω—Å: {user.balance - 1} —Ç–æ–∫–µ–Ω–æ–≤\"\n            )\n            \n            logger.info(f\"Video generation task created: {gen_id} by user {message.from_user.id}\")\n        else:\n            await progress_msg.edit_text(\n                \"‚ùå –û—à–∏–±–∫–∞ API –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∑–∞–¥–∞—á–∏\\n\\n\"\n                \"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É\"\n            )\n","size_bytes":14534},"main.py":{"content":"import asyncio\nimport logging\nimport os\nfrom typing import Optional\nfrom aiogram import Bot, Dispatcher\nfrom aiogram.client.default import DefaultBotProperties\nfrom aiogram.enums import ParseMode\nfrom aiogram.types import FSInputFile\nfrom aiogram.webhook.aiohttp_server import SimpleRequestHandler, setup_application\nfrom aiohttp import web\nimport aiohttp\nfrom app.config import settings\nfrom app.database import init_db, async_session_maker\nfrom app.repositories import GenerationTaskRepository\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s | %(levelname)s | %(name)s | %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nasync def send_generation_result(bot: Bot, task_id: str, user_chat_id: int, result_url: Optional[str] = None, error: Optional[str] = None):\n    \"\"\"Send generation result to user\"\"\"\n    try:\n        if result_url:\n            is_video = result_url.endswith(('.mp4', '.avi', '.mov', '.webm'))\n            \n            if is_video:\n                video_file = FSInputFile(result_url)\n                await bot.send_video(\n                    chat_id=user_chat_id,\n                    video=video_file,\n                    caption=\"‚úÖ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–∏–¥–µ–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!\\n\\n–û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ —Ñ–æ—Ç–æ –∏–ª–∏ –≤–∏–¥–µ–æ –¥–ª—è –Ω–æ–≤–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏.\"\n                )\n            else:\n                photo_file = FSInputFile(result_url)\n                await bot.send_photo(\n                    chat_id=user_chat_id,\n                    photo=photo_file,\n                    caption=\"‚úÖ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!\\n\\n–û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ —Ñ–æ—Ç–æ –∏–ª–∏ –≤–∏–¥–µ–æ –¥–ª—è –Ω–æ–≤–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏.\"\n                )\n        elif error:\n            await bot.send_message(\n                chat_id=user_chat_id,\n                text=f\"‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:\\n{error}\\n\\n–¢–æ–∫–µ–Ω –≤–æ–∑–≤—Ä–∞—â–µ–Ω –Ω–∞ –±–∞–ª–∞–Ω—Å.\"\n            )\n        else:\n            await bot.send_message(\n                chat_id=user_chat_id,\n                text=\"‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏\\n\\n–¢–æ–∫–µ–Ω –≤–æ–∑–≤—Ä–∞—â–µ–Ω –Ω–∞ –±–∞–ª–∞–Ω—Å.\"\n            )\n    except Exception as e:\n        logger.error(f\"Failed to send result to user {user_chat_id}: {e}\")\n\n\nasync def on_startup(bot: Bot):\n    \"\"\"Execute on bot startup\"\"\"\n    try:\n        await init_db()\n        logger.info(\"‚úÖ Database initialized\")\n    except Exception as e:\n        logger.error(f\"Database initialization error: {e}\")\n    \n    if settings.USE_WEBHOOK:\n        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—É—â–∏–π webhook\n        try:\n            current_webhook = await bot.get_webhook_info()\n            current_url = current_webhook.url\n            \n            # Production URL - –ù–ï –¢–†–û–ì–ê–ï–ú!\n            production_url = \"https://image-gen-bot.replit.app/webhook/telegram\"\n            \n            if current_url == production_url:\n                logger.info(f\"‚úÖ Webhook —É–∂–µ –Ω–∞ production: {production_url}\")\n                logger.info(f\"üìã Webhook info: {current_webhook}\")\n            else:\n                # Webhook –Ω–∞ dev –∏–ª–∏ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω - —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º\n                # –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: PRODUCTION –¥–æ–º–µ–Ω, –∑–∞—Ç–µ–º DEV, –∑–∞—Ç–µ–º fallback\n                replit_domain = os.getenv(\"REPLIT_DOMAINS\")\n                \n                if not replit_domain:\n                    replit_domain = os.getenv(\"REPLIT_DEV_DOMAIN\")\n                \n                if not replit_domain:\n                    replit_slug = os.getenv(\"REPL_SLUG\")\n                    replit_owner = os.getenv(\"REPL_OWNER\")\n                    if replit_slug and replit_owner:\n                        replit_domain = f\"{replit_slug}.{replit_owner}.repl.co\"\n                \n                # REPLIT_DOMAINS –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –¥–æ–º–µ–Ω–æ–≤ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é, –±–µ—Ä–µ–º –ø–µ—Ä–≤—ã–π\n                if replit_domain and ',' in replit_domain:\n                    replit_domain = replit_domain.split(',')[0].strip()\n                \n                if replit_domain:\n                    webhook_url = f\"https://{replit_domain}{settings.WEBHOOK_PATH}\"\n                    \n                    # Delete old webhook first\n                    await bot.delete_webhook(drop_pending_updates=True)\n                    logger.info(\"üóëÔ∏è Old webhook deleted\")\n                    \n                    # Set new webhook\n                    await bot.set_webhook(\n                        url=webhook_url,\n                        secret_token=settings.WEBHOOK_SECRET,\n                        drop_pending_updates=True\n                    )\n                    logger.info(f\"‚úÖ Webhook set: {webhook_url}\")\n                    \n                    # Verify webhook\n                    webhook_info = await bot.get_webhook_info()\n                    logger.info(f\"üìã Webhook info: {webhook_info}\")\n                else:\n                    logger.warning(\"‚ö†Ô∏è Domain not found, webhook not set\")\n        except Exception as e:\n            logger.error(f\"Failed to manage webhook: {e}\", exc_info=True)\n    else:\n        logger.info(\"Webhook mode disabled\")\n\n\nasync def on_shutdown(bot: Bot):\n    \"\"\"Execute on bot shutdown\"\"\"\n    await bot.delete_webhook()\n    logger.info(\"Bot stopped\")\n\n\ndef create_app():\n    \"\"\"Create and configure the application\"\"\"\n    bot = Bot(\n        token=settings.BOT_TOKEN,\n        default=DefaultBotProperties(parse_mode=ParseMode.HTML)\n    )\n    dp = Dispatcher()\n    \n    # Create alternative bot and dispatcher for Stars payments\n    from aiogram import Bot as AltBot, Dispatcher as AltDp, F\n    from aiogram.types import PreCheckoutQuery, Message as AltMessage\n    from app.repositories import UserRepository, TransactionRepository\n    \n    alt_bot = AltBot(\n        token=settings.ALT_BOT_TOKEN,\n        default=DefaultBotProperties(parse_mode=ParseMode.HTML)\n    )\n    alt_dp = AltDp()\n    \n    @alt_dp.pre_checkout_query()\n    async def alt_pre_checkout(pre_checkout: PreCheckoutQuery):\n        await pre_checkout.answer(ok=True)\n    \n    @alt_dp.message(F.successful_payment)\n    async def alt_successful_payment(message: AltMessage):\n        payment = message.successful_payment\n        new_balance = 0\n        try:\n            payload_parts = payment.invoice_payload.split(\"_\")\n            tokens = int(payload_parts[1])\n            user_id = int(payload_parts[2])\n            \n            async with async_session_maker() as session:\n                user_repo = UserRepository(session)\n                await user_repo.update_balance(user_id, tokens)\n                \n                user = await user_repo.get_by_chat_id(user_id)\n                if user:\n                    tx_repo = TransactionRepository(session)\n                    await tx_repo.create(\n                        user_id=int(user.id),\n                        amount=tokens,\n                        reason=f\"–ü–æ–∫—É–ø–∫–∞ —á–µ—Ä–µ–∑ Telegram Stars\",\n                        payment_method=\"stars\",\n                        external_id=payment.telegram_payment_charge_id\n                    )\n                    \n                    from app.services.referral import ReferralService\n                    ref_service = ReferralService(session)\n                    await ref_service.process_first_purchase(user_id, tokens)\n                    \n                    new_balance = user.balance\n            \n            await message.answer(\n                f\"‚úÖ –û–ø–ª–∞—Ç–∞ —É—Å–ø–µ—à–Ω–∞!\\n\\n\"\n                f\"üí∞ –ù–∞—á–∏—Å–ª–µ–Ω–æ: {tokens} —Ç–æ–∫–µ–Ω–æ–≤\\n\"\n                f\"üíµ –ù–æ–≤—ã–π –±–∞–ª–∞–Ω—Å: {new_balance} —Ç–æ–∫–µ–Ω–æ–≤\\n\\n\"\n                \"–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ñ–æ—Ç–æ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤ –æ—Å–Ω–æ–≤–Ω–æ–º –±–æ—Ç–µ!\"\n            )\n            \n            logger.info(f\"‚úÖ Stars payment: user={user_id}, tokens={tokens}\")\n            \n        except Exception as e:\n            logger.error(f\"Error processing Stars payment: {e}\")\n            await message.answer(\"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–ª–∞—Ç–µ–∂–∞. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É.\")\n    \n    from app.handlers import start, admin, payment, generate, referral, card_payment\n    dp.include_router(start.router)\n    dp.include_router(admin.router)\n    dp.include_router(payment.router)\n    dp.include_router(card_payment.router)\n    dp.include_router(generate.router)\n    dp.include_router(referral.router)\n    \n    # Fallback router with lowest priority - runs AFTER all other routers\n    from aiogram import Router, F\n    from aiogram.types import Message\n    fallback_router = Router()\n    \n    @fallback_router.message()\n    async def catch_all_messages(message: Message):\n        \"\"\"Catch all unhandled messages to prevent 'not handled' errors\"\"\"\n        user_id = message.from_user.id if message.from_user else 0\n        logger.info(f\"‚ö†Ô∏è Unhandled message from {user_id}: {message.text or message.content_type}\")\n    \n    @fallback_router.callback_query()\n    async def catch_all_callbacks(callback):\n        \"\"\"Catch all unhandled callbacks\"\"\"\n        logger.info(f\"‚ö†Ô∏è Unhandled callback from {callback.from_user.id}: {callback.data}\")\n        await callback.answer()\n    \n    # Include fallback router LAST with lowest priority\n    dp.include_router(fallback_router)\n    \n    from app.middlewares.admin import AdminMiddleware\n    dp.update.middleware(AdminMiddleware())\n    \n    dp.startup.register(on_startup)\n    dp.shutdown.register(on_shutdown)\n    \n    app = web.Application()\n    \n    async def telegram_webhook_wrapper(request):\n        \"\"\"Wrapper for telegram webhook with logging\"\"\"\n        logger.info(f\"üì• Incoming webhook request from {request.remote}\")\n        logger.info(f\"Headers: {dict(request.headers)}\")\n        body = await request.read()\n        logger.info(f\"Body size: {len(body)} bytes\")\n        \n        # Create new request with the same data\n        new_request = request\n        \n        # Call the original handler\n        webhook_handler = SimpleRequestHandler(\n            dispatcher=dp,\n            bot=bot,\n            secret_token=settings.WEBHOOK_SECRET\n        )\n        return await webhook_handler.handle(request)\n    \n    app.router.add_post(settings.WEBHOOK_PATH, telegram_webhook_wrapper)\n    \n    async def image_webhook(request):\n        \"\"\"Handle image generation webhook from external API\"\"\"\n        try:\n            logger.info(f\"üé® Image webhook received from {request.remote}\")\n            logger.info(f\"Content-Type: {request.content_type}\")\n            \n            gen_id = None\n            image_data = None\n            error = None\n            content_type = None\n            \n            # Parse multipart data\n            if 'multipart/form-data' in request.content_type:\n                reader = await request.multipart()\n                async for field in reader:\n                    field_name = field.name\n                    logger.info(f\"Field: {field_name}\")\n                    \n                    if field_name in ['undressingId', 'id_gen', 'id']:\n                        gen_id = await field.text()\n                        logger.info(f\"Generation ID: {gen_id}\")\n                    elif field_name == 'image':\n                        image_data = await field.read()\n                        content_type = field.headers.get('Content-Type', 'image/jpeg')\n                        logger.info(f\"Media size: {len(image_data)} bytes, type: {content_type}\")\n                    elif field_name == 'error':\n                        error = await field.text()\n                        logger.error(f\"API Error: {error}\")\n                    elif field_name == 'webhook':\n                        webhook_url = await field.text()\n                        logger.info(f\"Webhook URL: {webhook_url}\")\n            elif 'application/json' in request.content_type:\n                body = await request.read()\n                import json\n                data = json.loads(body)\n                logger.info(f\"JSON data: {data}\")\n                gen_id = data.get('id_gen') or data.get('undressingId') or data.get('id')\n                error = data.get('error')\n                image_url = data.get('image_url') or data.get('image')\n                if image_url and image_url.startswith('http'):\n                    async with aiohttp.ClientSession() as session:\n                        async with session.get(image_url) as resp:\n                            if resp.status == 200:\n                                image_data = await resp.read()\n            \n            logger.info(f\"‚úÖ Parsed: gen_id={gen_id}, has_image={bool(image_data)}, error={error}\")\n            \n            if gen_id:\n                async with async_session_maker() as session:\n                    task_repo = GenerationTaskRepository(session)\n                    task = await task_repo.get_by_task_id(gen_id)\n                    \n                    if task:\n                        if image_data:\n                            # Determine file extension based on content type\n                            if content_type and 'video' in content_type:\n                                file_ext = '.mp4'\n                            else:\n                                file_ext = '.jpg'\n                            \n                            file_path = f\"/tmp/{gen_id}{file_ext}\"\n                            with open(file_path, 'wb') as f:\n                                f.write(image_data)\n                            \n                            await task_repo.update_status(\n                                task_id=gen_id,\n                                status=\"completed\",\n                                result_url=file_path\n                            )\n                            \n                            from app.repositories import UserRepository\n                            user_repo = UserRepository(session)\n                            user = await session.get(User, task.user_id)\n                            \n                            if user:\n                                await send_generation_result(\n                                    bot=bot,\n                                    task_id=gen_id,\n                                    user_chat_id=int(user.chat_id),\n                                    result_url=file_path\n                                )\n                            \n                            logger.info(f\"‚úÖ Generation completed: {gen_id}\")\n                        elif error:\n                            await task_repo.update_status(\n                                task_id=gen_id,\n                                status=\"failed\",\n                                error_message=error\n                            )\n                            \n                            from app.repositories import UserRepository\n                            user_repo = UserRepository(session)\n                            user = await session.get(User, task.user_id)\n                            \n                            if user:\n                                await user_repo.update_balance(int(user.chat_id), 1)\n                                \n                                await send_generation_result(\n                                    bot=bot,\n                                    task_id=gen_id,\n                                    user_chat_id=int(user.chat_id),\n                                    error=error\n                                )\n                            \n                            logger.error(f\"‚ùå Generation failed: {gen_id} - {error}\")\n            \n            return web.Response(status=200, text=\"OK\")\n            \n        except Exception as e:\n            logger.error(f\"Webhook error: {e}\", exc_info=True)\n            return web.Response(status=500, text=str(e))\n    \n    async def health(request):\n        \"\"\"Health check endpoint\"\"\"\n        return web.Response(text=\"OK\", status=200)\n    \n    async def index(request):\n        \"\"\"Index page\"\"\"\n        return web.Response(\n            text=\"ü§ñ Telegram AI Image Generation Bot is running\",\n            status=200\n        )\n    \n    async def keep_alive_task():\n        \"\"\"Keep-alive task for deployment\"\"\"\n        while True:\n            try:\n                await asyncio.sleep(300)  # Every 5 minutes\n                logger.info(\"üíì Keep-alive heartbeat\")\n            except asyncio.CancelledError:\n                logger.info(\"Keep-alive task cancelled\")\n                break\n            except Exception as e:\n                logger.error(f\"Keep-alive error: {e}\")\n    \n    async def setup_alt_bot_webhook():\n        \"\"\"Setup webhook for alternative Stars bot\"\"\"\n        from aiogram import Bot as AltBot\n        \n        alt_bot = AltBot(\n            token=settings.ALT_BOT_TOKEN,\n            default=DefaultBotProperties(parse_mode=ParseMode.HTML)\n        )\n        \n        try:\n            # Check current webhook\n            current_webhook = await alt_bot.get_webhook_info()\n            production_url = \"https://image-gen-bot.replit.app/webhook/telegram_alt\"\n            \n            if current_webhook.url == production_url:\n                logger.info(f\"‚úÖ Alt bot webhook —É–∂–µ –Ω–∞ production: {production_url}\")\n            else:\n                # Set webhook for alt bot\n                replit_domain = os.getenv(\"REPLIT_DOMAINS\")\n                if not replit_domain:\n                    replit_domain = os.getenv(\"REPLIT_DEV_DOMAIN\")\n                \n                if replit_domain and ',' in replit_domain:\n                    replit_domain = replit_domain.split(',')[0].strip()\n                \n                if replit_domain:\n                    alt_webhook_url = f\"https://{replit_domain}/webhook/telegram_alt\"\n                    await alt_bot.delete_webhook(drop_pending_updates=True)\n                    await alt_bot.set_webhook(\n                        url=alt_webhook_url,\n                        secret_token=settings.WEBHOOK_SECRET,\n                        drop_pending_updates=True\n                    )\n                    logger.info(f\"‚úÖ Alt bot webhook set: {alt_webhook_url}\")\n        except Exception as e:\n            logger.error(f\"Failed to setup alt bot webhook: {e}\")\n        finally:\n            await alt_bot.session.close()\n    \n    async def start_background_tasks(app):\n        \"\"\"Start background tasks\"\"\"\n        app['keep_alive'] = asyncio.create_task(keep_alive_task())\n        # Setup alt bot webhook instead of polling\n        await setup_alt_bot_webhook()\n    \n    async def cleanup_background_tasks(app):\n        \"\"\"Cleanup background tasks\"\"\"\n        if 'keep_alive' in app:\n            app['keep_alive'].cancel()\n            try:\n                await app['keep_alive']\n            except asyncio.CancelledError:\n                pass\n    \n    app.on_startup.append(start_background_tasks)\n    app.on_cleanup.append(cleanup_background_tasks)\n    \n    app.router.add_post(\"/webhook/image_generation\", image_webhook)\n    app.router.add_get(\"/health\", health)\n    app.router.add_get(\"/\", index)\n    \n    # Setup main bot webhook\n    setup_application(app, dp, bot=bot)\n    \n    # Setup alternative bot webhook on different path\n    alt_webhook_handler = SimpleRequestHandler(\n        dispatcher=alt_dp,\n        bot=alt_bot,\n        secret_token=settings.WEBHOOK_SECRET\n    )\n    alt_webhook_handler.register(app, path=\"/webhook/telegram_alt\")\n    \n    return app\n\n\nfrom app.models import User\n\n\nif __name__ == \"__main__\":\n    port = int(os.getenv(\"PORT\", 5000))\n    logger.info(f\"üöÄ Starting bot on port {port}\")\n    app = create_app()\n    web.run_app(app, host=\"0.0.0.0\", port=port, print=None, reuse_port=True)\n","size_bytes":19757},"app/repositories.py":{"content":"from sqlalchemy import select, update\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom app.models import User, Transaction, Referral, GenerationTask, CardPaymentRequest, CardPaymentInstruction\nfrom app.config import settings\nfrom datetime import datetime\nfrom typing import Optional, List\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\nclass UserRepository:\n    def __init__(self, session: AsyncSession):\n        self.session = session\n    \n    async def get_or_create(self, chat_id: int, username: Optional[str] = None, referrer_chat_id: Optional[int] = None) -> User:\n        \"\"\"Get existing user or create new one\"\"\"\n        result = await self.session.execute(select(User).where(User.chat_id == chat_id))\n        user = result.scalar_one_or_none()\n        \n        if not user:\n            is_admin = chat_id in [int(x) for x in str(settings.ADMINS).split(\",\") if x.strip()]\n            \n            referrer_id = None\n            if referrer_chat_id:\n                ref_result = await self.session.execute(\n                    select(User).where(User.chat_id == referrer_chat_id)\n                )\n                referrer = ref_result.scalar_one_or_none()\n                if referrer:\n                    referrer_id = referrer.id\n            \n            user = User(\n                chat_id=chat_id,\n                username=username,\n                is_admin=is_admin,\n                referrer_id=referrer_id\n            )\n            self.session.add(user)\n            await self.session.commit()\n            await self.session.refresh(user)\n            logger.info(f\"New user created: {chat_id}\")\n        \n        return user\n    \n    async def get_by_chat_id(self, chat_id: int) -> Optional[User]:\n        \"\"\"Get user by chat_id\"\"\"\n        result = await self.session.execute(select(User).where(User.chat_id == chat_id))\n        return result.scalar_one_or_none()\n    \n    async def get_by_id(self, user_id: int) -> Optional[User]:\n        \"\"\"Get user by internal ID\"\"\"\n        return await self.session.get(User, user_id)\n    \n    async def update_balance(self, chat_id: int, amount: int) -> bool:\n        \"\"\"Update user balance\"\"\"\n        result = await self.session.execute(select(User).where(User.chat_id == chat_id))\n        user = result.scalar_one_or_none()\n        \n        if user:\n            user.balance += amount\n            user.updated_at = datetime.utcnow()\n            await self.session.commit()\n            logger.info(f\"User {chat_id} balance updated: {amount} (new balance: {user.balance})\")\n            return True\n        return False\n    \n    async def get_all_users(self) -> List[User]:\n        \"\"\"Get all users\"\"\"\n        result = await self.session.execute(select(User))\n        return result.scalars().all()\n    \n    async def set_admin(self, chat_id: int, is_admin: bool) -> bool:\n        \"\"\"Set admin status for user\"\"\"\n        result = await self.session.execute(select(User).where(User.chat_id == chat_id))\n        user = result.scalar_one_or_none()\n        \n        if user:\n            user.is_admin = is_admin\n            user.updated_at = datetime.utcnow()\n            await self.session.commit()\n            logger.info(f\"User {chat_id} admin status set to: {is_admin}\")\n            return True\n        return False\n    \n    async def get_all_admins(self) -> List[User]:\n        \"\"\"Get all admin users\"\"\"\n        result = await self.session.execute(select(User).where(User.is_admin == True))\n        return result.scalars().all()\n\n\nclass TransactionRepository:\n    def __init__(self, session: AsyncSession):\n        self.session = session\n    \n    async def create(\n        self,\n        user_id: int,\n        amount: int,\n        reason: str,\n        payment_method: Optional[str] = None,\n        external_id: Optional[str] = None\n    ) -> Transaction:\n        \"\"\"Create new transaction\"\"\"\n        transaction = Transaction(\n            user_id=user_id,\n            amount=amount,\n            reason=reason,\n            payment_method=payment_method,\n            external_id=external_id\n        )\n        self.session.add(transaction)\n        await self.session.commit()\n        await self.session.refresh(transaction)\n        logger.info(f\"Transaction created: user_id={user_id}, amount={amount}, reason={reason}\")\n        return transaction\n    \n    async def get_user_transactions(self, user_id: int) -> List[Transaction]:\n        \"\"\"Get all transactions for user\"\"\"\n        result = await self.session.execute(\n            select(Transaction).where(Transaction.user_id == user_id).order_by(Transaction.created_at.desc())\n        )\n        return result.scalars().all()\n\n\nclass ReferralRepository:\n    def __init__(self, session: AsyncSession):\n        self.session = session\n    \n    async def create(self, referrer_id: int, referee_id: int) -> Referral:\n        \"\"\"Create referral relationship\"\"\"\n        referral = Referral(referrer_id=referrer_id, referee_id=referee_id)\n        self.session.add(referral)\n        await self.session.commit()\n        await self.session.refresh(referral)\n        logger.info(f\"Referral created: referrer={referrer_id}, referee={referee_id}\")\n        return referral\n    \n    async def get_by_referrer(self, referrer_id: int) -> List[Referral]:\n        \"\"\"Get all referrals for referrer\"\"\"\n        result = await self.session.execute(\n            select(Referral).where(Referral.referrer_id == referrer_id)\n        )\n        return result.scalars().all()\n    \n    async def update_earned(self, referral_id: int, amount: int) -> bool:\n        \"\"\"Update total earned for referral\"\"\"\n        result = await self.session.execute(\n            select(Referral).where(Referral.id == referral_id)\n        )\n        referral = result.scalar_one_or_none()\n        \n        if referral:\n            referral.total_earned += amount\n            await self.session.commit()\n            return True\n        return False\n\n\nclass GenerationTaskRepository:\n    def __init__(self, session: AsyncSession):\n        self.session = session\n    \n    async def create(self, user_id: int, task_id: str, photo_id: str) -> GenerationTask:\n        \"\"\"Create new generation task\"\"\"\n        task = GenerationTask(\n            user_id=user_id,\n            task_id=task_id,\n            photo_telegram_id=photo_id\n        )\n        self.session.add(task)\n        await self.session.commit()\n        await self.session.refresh(task)\n        logger.info(f\"Generation task created: {task_id}\")\n        return task\n    \n    async def get_by_task_id(self, task_id: str) -> Optional[GenerationTask]:\n        \"\"\"Get task by task_id\"\"\"\n        result = await self.session.execute(\n            select(GenerationTask).where(GenerationTask.task_id == task_id)\n        )\n        return result.scalar_one_or_none()\n    \n    async def update_status(\n        self,\n        task_id: str,\n        status: str,\n        result_url: Optional[str] = None,\n        error_message: Optional[str] = None\n    ) -> bool:\n        \"\"\"Update task status\"\"\"\n        result = await self.session.execute(\n            select(GenerationTask).where(GenerationTask.task_id == task_id)\n        )\n        task = result.scalar_one_or_none()\n        \n        if task:\n            task.status = status\n            if result_url:\n                task.result_url = result_url\n            if error_message:\n                task.error_message = error_message\n            if status in [\"completed\", \"failed\"]:\n                task.completed_at = datetime.utcnow()\n            await self.session.commit()\n            logger.info(f\"Task {task_id} updated: status={status}\")\n            return True\n        return False\n\n\nclass CardPaymentRequestRepository:\n    def __init__(self, session: AsyncSession):\n        self.session = session\n    \n    async def create(\n        self,\n        user_id: int,\n        package_name: str,\n        tokens_amount: int,\n        card_type: str,\n        price_rub: Optional[int] = None,\n        price_usd: Optional[int] = None\n    ) -> CardPaymentRequest:\n        \"\"\"Create new card payment request\"\"\"\n        request = CardPaymentRequest(\n            user_id=user_id,\n            package_name=package_name,\n            tokens_amount=tokens_amount,\n            card_type=card_type,\n            price_rub=price_rub,\n            price_usd=price_usd\n        )\n        self.session.add(request)\n        await self.session.commit()\n        await self.session.refresh(request)\n        logger.info(f\"Card payment request created: user_id={user_id}, amount={tokens_amount}\")\n        return request\n    \n    async def get_by_id(self, request_id: int) -> Optional[CardPaymentRequest]:\n        \"\"\"Get request by ID\"\"\"\n        result = await self.session.execute(\n            select(CardPaymentRequest).where(CardPaymentRequest.id == request_id)\n        )\n        return result.scalar_one_or_none()\n    \n    async def get_pending(self) -> List[CardPaymentRequest]:\n        \"\"\"Get all pending payment requests\"\"\"\n        result = await self.session.execute(\n            select(CardPaymentRequest).where(CardPaymentRequest.status == \"pending\").order_by(CardPaymentRequest.created_at.desc())\n        )\n        return result.scalars().all()\n    \n    async def update_status(self, request_id: int, status: str, admin_response: Optional[str] = None) -> bool:\n        \"\"\"Update request status\"\"\"\n        result = await self.session.execute(\n            select(CardPaymentRequest).where(CardPaymentRequest.id == request_id)\n        )\n        request = result.scalar_one_or_none()\n        \n        if request:\n            request.status = status\n            if admin_response:\n                request.admin_response = admin_response\n            if status in [\"completed\", \"rejected\"]:\n                request.completed_at = datetime.utcnow()\n            await self.session.commit()\n            logger.info(f\"Card payment request {request_id} updated: status={status}\")\n            return True\n        return False\n    \n    async def update_receipt(self, request_id: int, receipt_file_id: str, admin_id: Optional[int] = None) -> bool:\n        \"\"\"Update receipt file_id and admin_id\"\"\"\n        result = await self.session.execute(\n            select(CardPaymentRequest).where(CardPaymentRequest.id == request_id)\n        )\n        request = result.scalar_one_or_none()\n        \n        if request:\n            request.receipt_file_id = receipt_file_id\n            if admin_id:\n                request.admin_id = admin_id\n            await self.session.commit()\n            logger.info(f\"Card payment request {request_id} receipt updated\")\n            return True\n        return False\n\n\nclass CardPaymentInstructionRepository:\n    def __init__(self, session: AsyncSession):\n        self.session = session\n    \n    async def get_or_create(self, card_type: str, default_text: str = \"\", default_requisites: str = \"\") -> CardPaymentInstruction:\n        \"\"\"Get instruction by card type or create default\"\"\"\n        result = await self.session.execute(\n            select(CardPaymentInstruction).where(CardPaymentInstruction.card_type == card_type)\n        )\n        instruction = result.scalar_one_or_none()\n        \n        if not instruction:\n            instruction = CardPaymentInstruction(\n                card_type=card_type,\n                instruction_text=default_text,\n                requisites=default_requisites\n            )\n            self.session.add(instruction)\n            await self.session.commit()\n            await self.session.refresh(instruction)\n            logger.info(f\"Card payment instruction created: {card_type}\")\n        \n        return instruction\n    \n    async def update(self, card_type: str, instruction_text: Optional[str] = None, requisites: Optional[str] = None) -> bool:\n        \"\"\"Update instruction\"\"\"\n        result = await self.session.execute(\n            select(CardPaymentInstruction).where(CardPaymentInstruction.card_type == card_type)\n        )\n        instruction = result.scalar_one_or_none()\n        \n        if instruction:\n            if instruction_text is not None:\n                instruction.instruction_text = instruction_text\n            if requisites is not None:\n                instruction.requisites = requisites\n            instruction.updated_at = datetime.utcnow()\n            await self.session.commit()\n            logger.info(f\"Card payment instruction updated: {card_type}\")\n            return True\n        return False\n    \n    async def get_all(self) -> List[CardPaymentInstruction]:\n        \"\"\"Get all instructions\"\"\"\n        result = await self.session.execute(select(CardPaymentInstruction))\n        return result.scalars().all()\n","size_bytes":12630},"replit.md":{"content":"# Telegram AI Image Generation Bot\n\n## –û–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞\n–ü–æ–ª–Ω–æ—Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π Telegram-–±–æ—Ç –Ω–∞ Python –¥–ª—è AI-–≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π —Å –º–æ–Ω–µ—Ç–∏–∑–∞—Ü–∏–µ–π —á–µ—Ä–µ–∑ Telegram Stars –∏ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—É.\n\n## –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π —Å—Ç–µ–∫\n- **Python**: 3.11\n- **Framework**: aiogram 3.13.1 (–∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π Telegram Bot API)\n- **–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö**: SQLite + SQLAlchemy (async)\n- **–ü–ª–∞—Ç–µ–∂–∏**: Telegram Stars + CryptoBot (USDT/TON/BTC)\n- **Image API**: Clothoff.net\n- **–†–µ–∂–∏–º**: Webhook –¥–ª—è production –Ω–∞ Replit\n\n## –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞\n```\n/\n‚îú‚îÄ‚îÄ main.py                    # –¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞ —Å webhook —Å–µ—Ä–≤–µ—Ä–æ–º\n‚îú‚îÄ‚îÄ requirements.txt           # Python –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏\n‚îú‚îÄ‚îÄ app/\n‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îú‚îÄ‚îÄ config.py             # –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —á–µ—Ä–µ–∑ pydantic\n‚îÇ   ‚îú‚îÄ‚îÄ database.py           # SQLite + SQLAlchemy setup\n‚îÇ   ‚îú‚îÄ‚îÄ models.py             # –ú–æ–¥–µ–ª–∏ –ë–î (User, Transaction, Referral, GenerationTask)\n‚îÇ   ‚îú‚îÄ‚îÄ repositories.py       # Data Access Layer\n‚îÇ   ‚îú‚îÄ‚îÄ services/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ image_api.py      # Clothoff.net API\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ crypto_payment.py # CryptoBot –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ referral.py       # –†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ billing.py        # –†–∞—Å—á–µ—Ç —Ü–µ–Ω\n‚îÇ   ‚îú‚îÄ‚îÄ handlers/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ start.py          # /start —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ admin.py          # –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ generate.py       # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ payment.py        # –û–ø–ª–∞—Ç–∞\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ referral.py       # –†–µ—Ñ–µ—Ä–∞–ª–∫–∞\n‚îÇ   ‚îú‚îÄ‚îÄ keyboards/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ inline.py         # Inline –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã\n‚îÇ   ‚îî‚îÄ‚îÄ middlewares/\n‚îÇ       ‚îî‚îÄ‚îÄ admin.py          # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∞\n‚îî‚îÄ‚îÄ bot.db                    # SQLite –±–∞–∑–∞ (–∞–≤—Ç–æ—Å–æ–∑–¥–∞–µ—Ç—Å—è)\n```\n\n## –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª\n1. **–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π** —á–µ—Ä–µ–∑ /start\n2. **AI-–≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π** - –æ—Ç–ø—Ä–∞–≤–∫–∞ —Ñ–æ—Ç–æ ‚Üí –æ–±—Ä–∞–±–æ—Ç–∫–∞ —á–µ—Ä–µ–∑ Clothoff.net API\n3. **–°–∏—Å—Ç–µ–º–∞ —Ç–æ–∫–µ–Ω–æ–≤** - –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –≤–∞–ª—é—Ç–∞ –¥–ª—è –æ–ø–ª–∞—Ç—ã –≥–µ–Ω–µ—Ä–∞—Ü–∏–π\n4. **–û–ø–ª–∞—Ç–∞ —á–µ—Ä–µ–∑ Telegram Stars** - –ø–∞–∫–µ—Ç—ã 10/25/50/100/200 —Ç–æ–∫–µ–Ω–æ–≤\n5. **–û–ø–ª–∞—Ç–∞ —á–µ—Ä–µ–∑ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—É** - USDT/TON/BTC —á–µ—Ä–µ–∑ CryptoBot\n6. **–†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞** - —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ —Å—Å—ã–ª–∫–∏, –±–æ–Ω—É—Å—ã –∑–∞ –ø—Ä–∏–≤–ª–µ—á–µ–Ω–∏–µ\n7. **–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å** - —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π\n8. **Webhook —Ä–µ–∂–∏–º** - –¥–ª—è production –Ω–∞ Replit\n\n## –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å–µ–∫—Ä–µ—Ç–æ–≤ –≤ Replit\n–î–æ–±–∞–≤—å—Ç–µ —Å–ª–µ–¥—É—é—â–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –≤ Secrets (üîí):\n- `BOT_TOKEN` - —Ç–æ–∫–µ–Ω –æ—Å–Ω–æ–≤–Ω–æ–≥–æ Telegram –±–æ—Ç–∞ (@baza_agent_bot)\n- `ALT_BOT_TOKEN` - —Ç–æ–∫–µ–Ω –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–æ–≥–æ –±–æ—Ç–∞ –¥–ª—è Stars (@stars_razdev_bot)\n- `ADMINS` - —Å–ø–∏—Å–æ–∫ admin ID —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é\n- `IMAGE_API_TOKEN` - —Ç–æ–∫–µ–Ω Clothoff.net API\n- `IMAGE_API_URL` - –±–∞–∑–æ–≤—ã–π URL API\n- `CRYPTO_BOT_TOKEN` - —Ç–æ–∫–µ–Ω CryptoBot –¥–ª—è –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—ã\n- `WEBHOOK_SECRET` - —Å–µ–∫—Ä–µ—Ç–Ω—ã–π —Ç–æ–∫–µ–Ω –¥–ª—è webhook\n- `DATABASE_URL` - –ø—É—Ç—å –∫ –ë–î (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é: sqlite+aiosqlite:///bot.db)\n\n## Deployment –Ω–∞ Replit\n1. –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –≤—Å–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –∏–∑ requirements.txt\n2. –ù–∞—Å—Ç—Ä–æ–µ–Ω—ã —Å–µ–∫—Ä–µ—Ç—ã –≤ Replit Secrets\n3. –ó–∞–ø—É—Å–∫ —á–µ—Ä–µ–∑ workflow –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç webhook\n4. –ë–æ—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ —Ä–µ–∂–∏–º–µ 24/7 —Å webhook\n\n## –ü–æ—Å–ª–µ–¥–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è\n- 2025-10-30 (08:51): –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–∞ —Å–∏—Å—Ç–µ–º–∞ –æ–ø–ª–∞—Ç—ã Stars —á–µ—Ä–µ–∑ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –±–æ—Ç ‚úÖ\n  - ‚úÖ –£–¥–∞–ª–µ–Ω—ã –Ω–∞—Ç–∏–≤–Ω—ã–µ Stars –∏–∑ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –±–æ—Ç–∞ (send_invoice)\n  - ‚úÖ –î–æ–±–∞–≤–ª–µ–Ω ALT_BOT_TOKEN –¥–ª—è –≤—Ç–æ—Ä–æ–≥–æ –±–æ—Ç–∞ (@stars_razdev_bot)\n  - ‚úÖ –°–æ–∑–¥–∞–Ω alt_bot.py –¥–ª—è –ø—Ä–∏—ë–º–∞ Stars –ø–ª–∞—Ç–µ–∂–µ–π —á–µ—Ä–µ–∑ –≤—Ç–æ—Ä–æ–π –±–æ—Ç\n  - ‚úÖ Invoice links —Å–æ–∑–¥–∞—é—Ç—Å—è —á–µ—Ä–µ–∑ ALT_BOT_TOKEN (–æ–±—Ö–æ–¥ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏)\n  - ‚úÖ –û–±–∞ –±–æ—Ç–∞ —Ä–∞–±–æ—Ç–∞—é—Ç –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ –±–µ–∑ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤\n  - ‚úÖ Stars –∏–¥—É—Ç –Ω–∞ –≤—Ç–æ—Ä–æ–π –±–æ—Ç, –æ—Å–Ω–æ–≤–Ω–æ–π –±–æ—Ç —Ç–æ–ª—å–∫–æ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏\n  - ‚úÖ –ü—Ä–∏ –±–ª–æ–∫–∏—Ä–æ–≤–∫–µ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –±–æ—Ç–∞ Stars –æ—Å—Ç–∞–Ω—É—Ç—Å—è –Ω–∞ –≤—Ç–æ—Ä–æ–º\n  \n- 2025-10-28 (16:54): –î–æ–±–∞–≤–ª–µ–Ω—ã —Ñ—É–Ω–∫—Ü–∏–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∞–¥–º–∏–Ω–∞–º–∏ –∏ –æ–ø–ª–∞—Ç—ã –∫–∞—Ä—Ç–æ–π ‚úÖ\n  - ‚úÖ –î–æ–±–∞–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å 742200799 –∫–∞–∫ –∞–¥–º–∏–Ω —á–µ—Ä–µ–∑ init_admin.py\n  - ‚úÖ –°–æ–∑–¥–∞–Ω–∞ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è —Å–∏—Å—Ç–µ–º–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∞–¥–º–∏–Ω–∞–º–∏ (add_admin/remove_admin commands)\n  - ‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–∞ –º–æ–¥–µ–ª—å CardPaymentRequest –≤ –ë–î\n  - ‚úÖ –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω card_payment handler —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π —Ä–æ—Å—Å–∏–π—Å–∫–∏—Ö/–º–µ–∂–¥—É–Ω–∞—Ä–æ–¥–Ω—ã—Ö –∫–∞—Ä—Ç\n  - ‚úÖ –ê–¥–º–∏–Ω—ã –ø–æ–ª—É—á–∞—é—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –Ω–æ–≤—ã—Ö –∑–∞—è–≤–∫–∞—Ö –Ω–∞ –æ–ø–ª–∞—Ç—É\n  - ‚úÖ –°–∏—Å—Ç–µ–º–∞ –æ—Ç–≤–µ—Ç–æ–≤ –∞–¥–º–∏–Ω–∞ —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –ø–µ—Ä–µ—Å—ã–ª–∫–æ–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é\n  - ‚úÖ –û–±–Ω–æ–≤–ª–µ–Ω—ã –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã: –¥–æ–±–∞–≤–ª–µ–Ω–∞ –∫–Ω–æ–ø–∫–∞ \"–ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å\" –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\n  - ‚úÖ –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω –≤—ã–±–æ—Ä —Å—Ç–∏–ª—è –ø–µ—Ä–µ–¥ –≥–µ–Ω–µ—Ä–∞—Ü–∏–µ–π (5 —Å—Ç–∏–ª–µ–π, –∫–∞–∫ –≤ Nudify Bot)\n  - ‚úÖ –î–æ–±–∞–≤–ª–µ–Ω FSM –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Å—Ç–∏–ª—è –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏\n  - ‚úÖ ImageGenerationAPI –æ–±–Ω–æ–≤–ª–µ–Ω –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ style\n  - ‚úÖ –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å —Ä–∞—Å—à–∏—Ä–µ–Ω–∞: \"–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∞–¥–º–∏–Ω–∞–º–∏\" –∏ \"–ó–∞—è–≤–∫–∏ –Ω–∞ –æ–ø–ª–∞—Ç—É\"\n  \n- 2025-10-28: –ü—Ä–æ–µ–∫—Ç –ø–æ–ª–Ω–æ—Å—Ç—å—é —Å–æ–∑–¥–∞–Ω –∏ –∑–∞–ø—É—â–µ–Ω ‚úÖ\n  - –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω—ã –≤—Å–µ –º–æ–¥–µ–ª–∏ –ë–î (User, Transaction, Referral, GenerationTask)\n  - –°–æ–∑–¥–∞–Ω—ã —Å–µ—Ä–≤–∏—Å—ã –¥–ª—è Image API, CryptoBot, Billing, Referral\n  - –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω—ã –≤—Å–µ handlers: start, admin, payment, generate, referral\n  - –ù–∞—Å—Ç—Ä–æ–µ–Ω webhook —Ä–µ–∂–∏–º –¥–ª—è Telegram Bot API\n  - –ò—Å–ø—Ä–∞–≤–ª–µ–Ω—ã –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –æ—à–∏–±–∫–∏ –∏–º–ø–æ—Ä—Ç–æ–≤ –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ñ–∞–π–ª–æ–≤\n  - –î–æ–±–∞–≤–ª–µ–Ω `reuse_port=True` –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏ –ø—Ä–∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–µ\n  - Webhook –ø–µ—Ä–µ—É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤—Ä—É—á–Ω—É—é - –±–æ—Ç —Ç–µ–ø–µ—Ä—å –ø–æ–ª—É—á–∞–µ—Ç –∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤—Å–µ –∑–∞–ø—Ä–æ—Å—ã\n  - **–ë–æ—Ç –ø–æ–ª–Ω–æ—Å—Ç—å—é —Ä–∞–±–æ—Ç–æ—Å–ø–æ—Å–æ–±–µ–Ω –∏ —Å—Ç–∞–±–∏–ª—å–Ω–æ –æ—Ç–≤–µ—á–∞–µ—Ç –Ω–∞ –∫–æ–º–∞–Ω–¥—ã!** üéâ\n\n## –ö–∞–∫ –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –±–æ—Ç–∞\n1. –ù–∞–π–¥–∏—Ç–µ –≤–∞—à–µ–≥–æ –±–æ—Ç–∞ –≤ Telegram (–∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–æ–∫–µ–Ω –∏–∑ BOT_TOKEN)\n2. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∫–æ–º–∞–Ω–¥—É `/start` - –±–æ—Ç –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç –≤–∞—Å\n3. –ö–æ–º–∞–Ω–¥–∞ `/buy` - –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –ø–∞–∫–µ—Ç—ã —Ç–æ–∫–µ–Ω–æ–≤ –¥–ª—è –ø–æ–∫—É–ø–∫–∏\n4. –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ - –±–æ—Ç –æ–±—Ä–∞–±–æ—Ç–∞–µ—Ç –µ–≥–æ —á–µ—Ä–µ–∑ AI API (—Ç—Ä–µ–±—É–µ—Ç—Å—è 1 —Ç–æ–∫–µ–Ω)\n5. –ö–æ–º–∞–Ω–¥–∞ `/ref` - –ø–æ–ª—É—á–∏—Ç—å —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω—É—é —Å—Å—ã–ª–∫—É\n6. –ö–æ–º–∞–Ω–¥–∞ `/admin` - –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å (—Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–æ–≤ –∏–∑ ADMINS)\n\n## –í–∞–∂–Ω—ã–µ endpoints\n- `/` - –≥–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ (—Å—Ç–∞—Ç—É—Å –±–æ—Ç–∞)\n- `/health` - health check\n- `/webhook/telegram` - webhook –¥–ª—è Telegram\n- `/webhook/image_generation` - webhook –¥–ª—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏\n\n## Deployment\n- **Development**: –ù–∞–∂–º–∏—Ç–µ \"Run\" - –±–æ—Ç –∑–∞–ø—É—Å—Ç–∏—Ç—Å—è –ª–æ–∫–∞–ª—å–Ω–æ –Ω–∞ –ø–æ—Ä—Ç—É 5000\n- **Production**: –ù–∞–∂–º–∏—Ç–µ \"Deploy\" - –±–æ—Ç –¥–µ–ø–ª–æ–∏—Ç—Å—è –Ω–∞ Replit Autoscale\n- Deployment –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –≤ `.replit`:\n  - `deploymentTarget = \"autoscale\"` - –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ\n  - `build = [\"pip\", \"install\", \"-r\", \"requirements.txt\"]` - —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π\n  - `run = [\"python3\", \"main.py\"]` - –∫–æ–º–∞–Ω–¥–∞ –∑–∞–ø—É—Å–∫–∞\n- Health checks –¥–æ—Å—Ç—É–ø–Ω—ã –Ω–∞ `/` –∏ `/health` (–æ—Ç–≤–µ—á–∞—é—Ç –∑–∞ 2-4ms)\n- Webhook –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ\n- –ü–æ–¥—Ä–æ–±–Ω–µ–µ —Å–º. [DEPLOYMENT.md](DEPLOYMENT.md)\n\n## –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã\n- 2025-10-28: –ò—Å–ø—Ä–∞–≤–ª–µ–Ω deployment –¥–ª—è Cloud Run ‚úÖ\n  - ‚úÖ –£–±—Ä–∞–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è $file –∏–∑ run command\n  - ‚úÖ –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ —è–≤–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞ –∑–∞–ø—É—Å–∫–∞: `[\"python3\", \"main.py\"]`\n  - ‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–∞ build –∫–æ–º–∞–Ω–¥–∞: `[\"pip\", \"install\", \"-r\", \"requirements.txt\"]`\n  - ‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –≤ startup –¥–ª—è –±—ã—Å—Ç—Ä—ã—Ö health checks\n  - ‚úÖ Health check endpoints –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω—ã (–≤—Ä–µ–º—è –æ—Ç–∫–ª–∏–∫–∞ 2-4ms)\n  - ‚úÖ Deployment target —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –Ω–∞ \"autoscale\" –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è\n  - ‚úÖ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç—Å—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –±–µ–∑ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ health checks\n  \n**–†–µ–∑—É–ª—å—Ç–∞—Ç**: Deployment –≥–æ—Ç–æ–≤ –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é! –í—Å–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø—Ä–∏–º–µ–Ω–µ–Ω—ã –∏ –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω—ã.\n","size_bytes":9763},"app/models.py":{"content":"from sqlalchemy import Column, Integer, BigInteger, String, Boolean, DateTime, ForeignKey\nfrom sqlalchemy.orm import declarative_base, relationship\nfrom datetime import datetime\n\nBase = declarative_base()\n\n\nclass User(Base):\n    __tablename__ = \"users\"\n    \n    id = Column(Integer, primary_key=True)\n    chat_id = Column(BigInteger, unique=True, nullable=False, index=True)\n    username = Column(String, nullable=True)\n    balance = Column(Integer, default=0)\n    is_admin = Column(Boolean, default=False, index=True)\n    referrer_id = Column(Integer, ForeignKey(\"users.id\"), nullable=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    \n    referrals = relationship(\"Referral\", foreign_keys=\"Referral.referrer_id\", back_populates=\"referrer\")\n    generation_tasks = relationship(\"GenerationTask\", back_populates=\"user\")\n    transactions = relationship(\"Transaction\", back_populates=\"user\")\n\n\nclass Transaction(Base):\n    __tablename__ = \"transactions\"\n    \n    id = Column(Integer, primary_key=True)\n    user_id = Column(Integer, ForeignKey(\"users.id\"))\n    amount = Column(Integer)\n    reason = Column(String)\n    payment_method = Column(String, nullable=True)\n    external_id = Column(String, nullable=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    \n    user = relationship(\"User\", back_populates=\"transactions\")\n\n\nclass Referral(Base):\n    __tablename__ = \"referrals\"\n    \n    id = Column(Integer, primary_key=True)\n    referrer_id = Column(Integer, ForeignKey(\"users.id\"))\n    referee_id = Column(Integer, ForeignKey(\"users.id\"))\n    total_earned = Column(Integer, default=0)\n    first_purchase_bonus_given = Column(Boolean, default=False)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    \n    referrer = relationship(\"User\", foreign_keys=[referrer_id], back_populates=\"referrals\")\n\n\nclass GenerationTask(Base):\n    __tablename__ = \"generation_tasks\"\n    \n    id = Column(Integer, primary_key=True)\n    user_id = Column(Integer, ForeignKey(\"users.id\"))\n    task_id = Column(String, unique=True, index=True)\n    status = Column(String, default=\"processing\")\n    photo_telegram_id = Column(String)\n    style = Column(String, nullable=True)\n    result_url = Column(String, nullable=True)\n    error_message = Column(String, nullable=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    completed_at = Column(DateTime, nullable=True)\n    \n    user = relationship(\"User\", back_populates=\"generation_tasks\")\n\n\nclass CardPaymentRequest(Base):\n    __tablename__ = \"card_payment_requests\"\n    \n    id = Column(Integer, primary_key=True)\n    user_id = Column(Integer, ForeignKey(\"users.id\"))\n    package_name = Column(String)\n    tokens_amount = Column(Integer)\n    price_rub = Column(Integer, nullable=True)\n    price_usd = Column(Integer, nullable=True)\n    card_type = Column(String)\n    status = Column(String, default=\"pending\")\n    receipt_file_id = Column(String, nullable=True)\n    admin_id = Column(Integer, ForeignKey(\"users.id\"), nullable=True)\n    admin_response = Column(String, nullable=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    completed_at = Column(DateTime, nullable=True)\n\n\nclass CardPaymentInstruction(Base):\n    __tablename__ = \"card_payment_instructions\"\n    \n    id = Column(Integer, primary_key=True)\n    card_type = Column(String, unique=True, nullable=False)\n    instruction_text = Column(String, nullable=False)\n    requisites = Column(String, nullable=False)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n","size_bytes":3646},"app/keyboards/inline.py":{"content":"from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\nfrom app.config import settings\n\n\ndef main_menu_keyboard() -> InlineKeyboardMarkup:\n    \"\"\"Main menu keyboard\"\"\"\n    keyboard = InlineKeyboardMarkup(inline_keyboard=[\n        [InlineKeyboardButton(text=\"üé® –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å\", callback_data=\"start_generation\")],\n        [InlineKeyboardButton(text=\"üí∞ –ö—É–ø–∏—Ç—å —Ç–æ–∫–µ–Ω—ã\", callback_data=\"buy_menu\")],\n        [InlineKeyboardButton(text=\"üíé –ë–∞–ª–∞–Ω—Å\", callback_data=\"profile\")],\n        [InlineKeyboardButton(text=\"üîó –ü—Ä–∏–≥–ª–∞—Å–∏—Ç—å –¥—Ä—É–∑–µ–π\", callback_data=\"referral_info\")],\n        [InlineKeyboardButton(text=\"‚ÑπÔ∏è –ü–æ–º–æ—â—å\", callback_data=\"help\")]\n    ])\n    return keyboard\n\n\ndef buy_tokens_keyboard() -> InlineKeyboardMarkup:\n    \"\"\"Buy tokens menu keyboard\"\"\"\n    buttons = []\n    \n    buttons.append([InlineKeyboardButton(text=\"‚≠ê Telegram Stars\", callback_data=\"buy_stars_alt_menu\")])\n    buttons.append([InlineKeyboardButton(text=\"üíé –û–ø–ª–∞—Ç–∞ –∫—Ä–∏–ø—Ç–æ–π\", callback_data=\"buy_crypto_menu\")])\n    buttons.append([InlineKeyboardButton(text=\"üí≥ –û–ø–ª–∞—Ç–∞ –∫–∞—Ä—Ç–æ–π\", callback_data=\"buy_card_menu\")])\n    buttons.append([InlineKeyboardButton(text=\"‚óÄÔ∏è –ù–∞–∑–∞–¥\", callback_data=\"main_menu\")])\n    \n    return InlineKeyboardMarkup(inline_keyboard=buttons)\n\n\ndef card_payment_keyboard() -> InlineKeyboardMarkup:\n    \"\"\"Card payment menu keyboard\"\"\"\n    keyboard = InlineKeyboardMarkup(inline_keyboard=[\n        [InlineKeyboardButton(text=\"üá∑üá∫ –†–æ—Å—Å–∏–π—Å–∫–∞—è –∫–∞—Ä—Ç–∞\", callback_data=\"card_ru\")],\n        [InlineKeyboardButton(text=\"üåç –ú–µ–∂–¥—É–Ω–∞—Ä–æ–¥–Ω–∞—è –∫–∞—Ä—Ç–∞\", callback_data=\"card_intl\")],\n        [InlineKeyboardButton(text=\"‚óÄÔ∏è –ù–∞–∑–∞–¥\", callback_data=\"buy_menu\")]\n    ])\n    return keyboard\n\n\ndef crypto_payment_keyboard() -> InlineKeyboardMarkup:\n    \"\"\"Crypto payment menu keyboard\"\"\"\n    keyboard = InlineKeyboardMarkup(inline_keyboard=[\n        [InlineKeyboardButton(text=\"üíµ USDT\", callback_data=\"crypto_usdt\")],\n        [InlineKeyboardButton(text=\"üíé TON\", callback_data=\"crypto_ton\")],\n        [InlineKeyboardButton(text=\"‚Çø BTC\", callback_data=\"crypto_btc\")],\n        [InlineKeyboardButton(text=\"‚óÄÔ∏è –ù–∞–∑–∞–¥\", callback_data=\"buy_menu\")]\n    ])\n    return keyboard\n\n\ndef admin_keyboard() -> InlineKeyboardMarkup:\n    \"\"\"Admin panel keyboard\"\"\"\n    keyboard = InlineKeyboardMarkup(inline_keyboard=[\n        [InlineKeyboardButton(text=\"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞\", callback_data=\"admin_stats\")],\n        [InlineKeyboardButton(text=\"üë• –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏\", callback_data=\"admin_users\")],\n        [InlineKeyboardButton(text=\"üí∞ –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏\", callback_data=\"admin_transactions\")],\n        [InlineKeyboardButton(text=\"üë®‚Äçüíº –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∞–¥–º–∏–Ω–∞–º–∏\", callback_data=\"admin_manage\")],\n        [InlineKeyboardButton(text=\"üí≥ –ó–∞—è–≤–∫–∏ –Ω–∞ –æ–ø–ª–∞—Ç—É\", callback_data=\"admin_payment_requests\")],\n        [InlineKeyboardButton(text=\"‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –æ–ø–ª–∞—Ç—ã\", callback_data=\"admin_payment_settings\")],\n        [InlineKeyboardButton(text=\"‚óÄÔ∏è –ù–∞–∑–∞–¥\", callback_data=\"main_menu\")]\n    ])\n    return keyboard\n\n\ndef generation_styles_keyboard() -> InlineKeyboardMarkup:\n    \"\"\"Generation styles selection keyboard\"\"\"\n    keyboard = InlineKeyboardMarkup(inline_keyboard=[\n        [InlineKeyboardButton(text=\"üëó –°—Ç–∏–ª—å 1\", callback_data=\"style_1\")],\n        [InlineKeyboardButton(text=\"üíÉ –°—Ç–∏–ª—å 2\", callback_data=\"style_2\")],\n        [InlineKeyboardButton(text=\"üëô –°—Ç–∏–ª—å 3\", callback_data=\"style_3\")],\n        [InlineKeyboardButton(text=\"üî• –°—Ç–∏–ª—å 4\", callback_data=\"style_4\")],\n        [InlineKeyboardButton(text=\"‚ú® –°—Ç–∏–ª—å 5\", callback_data=\"style_5\")],\n        [InlineKeyboardButton(text=\"‚óÄÔ∏è –ù–∞–∑–∞–¥\", callback_data=\"main_menu\")]\n    ])\n    return keyboard\n\n\ndef back_to_main_keyboard() -> InlineKeyboardMarkup:\n    \"\"\"Back to main menu keyboard\"\"\"\n    keyboard = InlineKeyboardMarkup(inline_keyboard=[\n        [InlineKeyboardButton(text=\"‚óÄÔ∏è –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\", callback_data=\"main_menu\")]\n    ])\n    return keyboard\n\n\ndef video_models_keyboard() -> InlineKeyboardMarkup:\n    \"\"\"Video animation models selection keyboard\"\"\"\n    models = [\n        (\"üíã Blowjob\", \"M0d1IGEkCkeys3z\"),\n        (\"üçí Bouncy tits\", \"egncvJ0CJemcUX5\"),\n        (\"üë£ Footjob\", \"qJ9KByOKlNrnD7X\"),\n        (\"üí¶ Squirt\", \"MgP3RMTMxrQ4xn1\"),\n        (\"‚ù§Ô∏è Hand heart\", \"9IoEyMGTQNBUlSW\"),\n        (\"üíè Lesbian Kiss\", \"3Fj2x7hzDreTCp6x817DU\"),\n        (\"üòõ Ahegao\", \"tgPcSA8laTd0yv4\"),\n        (\"‚úä Masturbation\", \"D99MLg6R0gi9hJd\"),\n        (\"üõè Missionary\", \"FRt2l4RDDHu979d\"),\n        (\"üëÜ Fingering\", \"50tZbquENp3P97K\"),\n        (\"üîÆ Witch Spell\", \"J_I-rb2LVwgshO47iEX-W\"),\n        (\"üêï Doggy style\", \"t39EDWrEckcwwmA\"),\n        (\"üçë Twerk\", \"eMYnaGciQuqm7wi\"),\n        (\"‚ú® Poof!\", \"VRYrEWtdZmZzP9avklJup\"),\n        (\"üçë Ass Spanks\", \"wCLrc7XPsqOui6Z\"),\n        (\"üèá Reverse Cowgirl\", \"DKvEpidXcX6NfLX\"),\n        (\"üëô Shows tits\", \"Tsl6UFbtiYmJhiA\"),\n    ]\n    \n    buttons = []\n    for i in range(0, len(models), 2):\n        row = []\n        row.append(InlineKeyboardButton(text=models[i][0], callback_data=f\"video_model_{models[i][1]}\"))\n        if i + 1 < len(models):\n            row.append(InlineKeyboardButton(text=models[i+1][0], callback_data=f\"video_model_{models[i+1][1]}\"))\n        buttons.append(row)\n    \n    buttons.append([InlineKeyboardButton(text=\"‚óÄÔ∏è –ù–∞–∑–∞–¥\", callback_data=\"main_menu\")])\n    \n    return InlineKeyboardMarkup(inline_keyboard=buttons)\n","size_bytes":5625},"app/config.py":{"content":"import os\nfrom pydantic_settings import BaseSettings\nfrom typing import List, Optional\nimport json\n\n\nclass Settings(BaseSettings):\n    BOT_TOKEN: str\n    ALT_BOT_TOKEN: str\n    ADMINS: str\n    IMAGE_API_TOKEN: str\n    IMAGE_API_URL: str\n    CRYPTO_BOT_TOKEN: str\n    SQLITE_DATABASE_URL: Optional[str] = None\n    USE_WEBHOOK: bool = True\n    WEBHOOK_HOST: str = \"\"\n    WEBHOOK_PATH: str = \"/webhook/telegram\"\n    WEBHOOK_SECRET: str = \"\"\n    PRICE_SELL_RUB: str = \"35\"\n    STARS_PACKS: str = '[{\"tokens\":10,\"stars\":194,\"discount\":0},{\"tokens\":25,\"stars\":486,\"discount\":10},{\"tokens\":50,\"stars\":972,\"discount\":15},{\"tokens\":100,\"stars\":1944,\"discount\":20},{\"tokens\":200,\"stars\":3889,\"discount\":25}]'\n    REFERRAL_BONUS_TOKENS: str = \"2\"\n    REFERRAL_COMMISSION_PERCENT: str = \"10\"\n    \n    @property\n    def database_url(self) -> str:\n        \"\"\"Get database URL, prefer SQLITE_DATABASE_URL over DATABASE_URL\"\"\"\n        if self.SQLITE_DATABASE_URL:\n            return self.SQLITE_DATABASE_URL\n        return \"sqlite+aiosqlite:///./bot.db\"\n    \n    @property\n    def admin_ids(self) -> List[int]:\n        return [int(x.strip()) for x in self.ADMINS.split(\",\") if x.strip()]\n    \n    @property\n    def stars_packs_list(self) -> List[dict]:\n        try:\n            return json.loads(self.STARS_PACKS)\n        except:\n            return [{\"tokens\": 10, \"stars\": 194, \"discount\": 0}]\n    \n    @property\n    def referral_bonus(self) -> int:\n        return int(self.REFERRAL_BONUS_TOKENS)\n    \n    @property\n    def referral_commission(self) -> int:\n        return int(self.REFERRAL_COMMISSION_PERCENT)\n    \n    class Config:\n        env_file = \".env\"\n        case_sensitive = True\n\n\nsettings = Settings()\n","size_bytes":1699},"app/middlewares/admin.py":{"content":"from typing import Callable, Dict, Any, Awaitable\nfrom aiogram import BaseMiddleware\nfrom aiogram.types import Update\nfrom app.config import settings\n\n\nclass AdminMiddleware(BaseMiddleware):\n    \"\"\"Middleware to check admin rights\"\"\"\n    \n    def _is_admin(self, chat_id: int) -> bool:\n        \"\"\"Check if user is admin\"\"\"\n        try:\n            admin_ids = [int(admin_id) for admin_id in settings.ADMINS.split(\",\") if admin_id.strip()]\n            return chat_id in admin_ids\n        except:\n            return False\n    \n    async def __call__(\n        self,\n        handler: Callable[[Update, Dict[str, Any]], Awaitable[Any]],\n        event: Update,\n        data: Dict[str, Any]\n    ) -> Any:\n        user = data.get(\"event_from_user\")\n        if user:\n            data[\"is_admin\"] = self._is_admin(user.id)\n        else:\n            data[\"is_admin\"] = False\n        \n        return await handler(event, data)\n","size_bytes":915},"app/services/__init__.py":{"content":"","size_bytes":0},"app/handlers/card_payment.py":{"content":"from aiogram import Router, F\nfrom aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton\nfrom aiogram.fsm.context import FSMContext\nfrom app.database import async_session_maker\nfrom app.repositories import UserRepository, CardPaymentRequestRepository, CardPaymentInstructionRepository, TransactionRepository\nfrom app.keyboards.inline import card_payment_keyboard, back_to_main_keyboard\nfrom app.config import settings\nfrom app.states import CardPaymentStates\nimport logging\n\nlogger = logging.getLogger(__name__)\nrouter = Router()\n\n\n@router.callback_query(F.data == \"buy_card_menu\")\nasync def show_card_menu(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Show card payment menu\"\"\"\n    await state.clear()\n    \n    text = (\n        \"üí≥ –û–ø–ª–∞—Ç–∞ –∫–∞—Ä—Ç–æ–π\\n\\n\"\n        \"–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –∫–∞—Ä—Ç—ã:\"\n    )\n    \n    await callback.message.edit_text(text, reply_markup=card_payment_keyboard())\n    await callback.answer()\n\n\n@router.callback_query(F.data.in_([\"card_ru\", \"card_intl\"]))\nasync def select_card_type(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Select card type and show packages\"\"\"\n    card_type = \"ru\" if callback.data == \"card_ru\" else \"intl\"\n    await state.update_data(card_type=card_type)\n    await state.set_state(CardPaymentStates.selecting_package)\n    \n    card_name = \"–†–æ—Å—Å–∏–π—Å–∫–∞—è\" if card_type == \"ru\" else \"–ú–µ–∂–¥—É–Ω–∞—Ä–æ–¥–Ω–∞—è\"\n    \n    packages = settings.stars_packs_list\n    text = f\"üí≥ {card_name} –∫–∞—Ä—Ç–∞\\n\\n–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞–∫–µ—Ç —Ç–æ–∫–µ–Ω–æ–≤:\\n\\n\"\n    \n    keyboard_buttons = []\n    for pack in packages:\n        tokens = pack[\"tokens\"]\n        stars = pack[\"stars\"]\n        price_rub = int(stars * 1.5)\n        keyboard_buttons.append([InlineKeyboardButton(\n            text=f\"‚≠êÔ∏è {tokens} —Ç–æ–∫–µ–Ω–æ–≤ ({price_rub} ‚ÇΩ)\",\n            callback_data=f\"card_pack_{tokens}_{card_type}\"\n        )])\n    \n    keyboard_buttons.append([InlineKeyboardButton(text=\"‚óÄÔ∏è –ù–∞–∑–∞–¥\", callback_data=\"buy_card_menu\")])\n    keyboard = InlineKeyboardMarkup(inline_keyboard=keyboard_buttons)\n    \n    await callback.message.edit_text(text, reply_markup=keyboard)\n    await callback.answer()\n\n\n@router.callback_query(F.data.startswith(\"card_pack_\"), CardPaymentStates.selecting_package)\nasync def process_card_package_selection(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Show payment instructions after package selection\"\"\"\n    try:\n        parts = callback.data.split(\"_\")\n        tokens = int(parts[2])\n        card_type = parts[3]\n        \n        async with async_session_maker() as session:\n            user_repo = UserRepository(session)\n            user = await user_repo.get_by_chat_id(callback.from_user.id)\n            \n            if not user:\n                await state.clear()\n                await callback.answer(\"–û—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω\", show_alert=True)\n                return\n            \n            package = next((p for p in settings.stars_packs_list if p[\"tokens\"] == tokens), None)\n            if not package:\n                await state.clear()\n                await callback.answer(\"–û—à–∏–±–∫–∞: –ø–∞–∫–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω\", show_alert=True)\n                return\n            \n            price_rub = int(package[\"stars\"] * 1.5)\n            \n            payment_repo = CardPaymentRequestRepository(session)\n            request = await payment_repo.create(\n                user_id=user.id,\n                package_name=f\"{tokens} —Ç–æ–∫–µ–Ω–æ–≤\",\n                tokens_amount=tokens,\n                card_type=card_type,\n                price_rub=price_rub if card_type == \"ru\" else None,\n                price_usd=int(price_rub / 90) if card_type == \"intl\" else None\n            )\n            \n            instr_repo = CardPaymentInstructionRepository(session)\n            instruction = await instr_repo.get_or_create(\n                card_type=card_type,\n                default_text=\"–ü–µ—Ä–µ–≤–µ–¥–∏—Ç–µ —É–∫–∞–∑–∞–Ω–Ω—É—é —Å—É–º–º—É –Ω–∞ —Ä–µ–∫–≤–∏–∑–∏—Ç—ã –Ω–∏–∂–µ –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–∫—Ä–∏–Ω—à–æ—Ç —á–µ–∫–∞.\",\n                default_requisites=\"2200 0000 2200 0000\" if card_type == \"ru\" else \"4111 1111 1111 1111\"\n            )\n        \n        card_name = \"–†–æ—Å—Å–∏–π—Å–∫–∞—è\" if card_type == \"ru\" else \"–ú–µ–∂–¥—É–Ω–∞—Ä–æ–¥–Ω–∞—è\"\n        price = f\"{price_rub} ‚ÇΩ\" if card_type == \"ru\" else f\"${int(price_rub / 90)}\"\n        \n        text = (\n            f\"üí≥ –û–ø–ª–∞—Ç–∞ –∫–∞—Ä—Ç–æ–π ({card_name})\\n\\n\"\n            f\"üì¶ –ü–∞–∫–µ—Ç: {tokens} —Ç–æ–∫–µ–Ω–æ–≤\\n\"\n            f\"üí∞ –°—É–º–º–∞: {price}\\n\\n\"\n            f\"üìù {instruction.instruction_text}\\n\\n\"\n            f\"üí≥ –†–µ–∫–≤–∏–∑–∏—Ç—ã:\\n<code>{instruction.requisites}</code>\\n\\n\"\n            f\"–ü–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–∫—Ä–∏–Ω—à–æ—Ç —á–µ–∫–∞ –±–æ—Ç—É.\"\n        )\n        \n        keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"‚óÄÔ∏è –û—Ç–º–µ–Ω–∏—Ç—å\", callback_data=\"buy_card_menu\")]\n        ])\n        \n        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode=\"HTML\")\n        await callback.answer(\"–û–∂–∏–¥–∞–µ–º —Å–∫—Ä–∏–Ω—à–æ—Ç —á–µ–∫–∞\")\n        \n        await state.update_data(request_id=request.id, tokens=tokens, price=price, card_name=card_name)\n        await state.set_state(CardPaymentStates.waiting_receipt)\n    \n    except Exception as e:\n        logger.error(f\"Error in process_card_package_selection: {e}\", exc_info=True)\n        await state.clear()\n        await callback.answer(\"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.\", show_alert=True)\n\n\n@router.message(CardPaymentStates.waiting_receipt, F.photo)\nasync def receive_receipt_photo(message: Message, state: FSMContext):\n    \"\"\"Receive receipt photo from user\"\"\"\n    try:\n        data = await state.get_data()\n        request_id = data.get(\"request_id\")\n        tokens = data.get(\"tokens\")\n        price = data.get(\"price\")\n        card_name = data.get(\"card_name\")\n        \n        if not request_id:\n            await message.answer(\"‚ùå –û—à–∏–±–∫–∞: –∑–∞—è–≤–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ —á–µ—Ä–µ–∑ /start\")\n            await state.clear()\n            return\n        \n        photo = message.photo[-1]\n        file_id = photo.file_id\n        \n        async with async_session_maker() as session:\n            payment_repo = CardPaymentRequestRepository(session)\n            await payment_repo.update_receipt(request_id, file_id)\n            \n            user_repo = UserRepository(session)\n            admins = await user_repo.get_all_admins()\n            \n            for admin in admins:\n                try:\n                    admin_text = (\n                        f\"üÜï –ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞ –Ω–∞ –æ–ø–ª–∞—Ç—É –∫–∞—Ä—Ç–æ–π!\\n\\n\"\n                        f\"üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {message.from_user.full_name}\\n\"\n                        f\"üÜî ID: {message.from_user.id}\\n\"\n                        f\"üì¶ –ü–∞–∫–µ—Ç: {tokens} —Ç–æ–∫–µ–Ω–æ–≤\\n\"\n                        f\"üí≥ –¢–∏–ø –∫–∞—Ä—Ç—ã: {card_name}\\n\"\n                        f\"üí∞ –°—É–º–º–∞: {price}\\n\\n\"\n                        f\"üì∏ –ß–µ–∫ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:\"\n                    )\n                    \n                    admin_keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                        [InlineKeyboardButton(text=\"‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –æ–ø–ª–∞—Ç—É\", callback_data=f\"confirm_card_{request_id}\")],\n                        [InlineKeyboardButton(text=\"‚ùå –û—Ç–∫–ª–æ–Ω–∏—Ç—å\", callback_data=f\"reject_card_{request_id}\")]\n                    ])\n                    \n                    await message.bot.send_photo(\n                        admin.chat_id,\n                        file_id,\n                        caption=admin_text,\n                        reply_markup=admin_keyboard\n                    )\n                except Exception as e:\n                    logger.error(f\"Failed to notify admin {admin.chat_id}: {e}\")\n        \n        await message.answer(\n            \"‚úÖ –ß–µ–∫ –ø–æ–ª—É—á–µ–Ω!\\n\\n\"\n            \"–í–∞—à–∞ –∑–∞—è–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫—É.\\n\"\n            \"–û–∂–∏–¥–∞–π—Ç–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –æ–ø–ª–∞—Ç—ã.\",\n            reply_markup=back_to_main_keyboard()\n        )\n        \n        await state.clear()\n    \n    except Exception as e:\n        logger.error(f\"Error receiving receipt: {e}\", exc_info=True)\n        await message.answer(\"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.\")\n        await state.clear()\n\n\n@router.message(CardPaymentStates.waiting_receipt)\nasync def waiting_receipt_other_content(message: Message):\n    \"\"\"Handle non-photo messages while waiting for receipt\"\"\"\n    await message.answer(\n        \"‚ö†Ô∏è –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–∫—Ä–∏–Ω—à–æ—Ç —á–µ–∫–∞ (—Ñ–æ—Ç–æ).\\n\\n\"\n        \"–ï—Å–ª–∏ —Ö–æ—Ç–∏—Ç–µ –æ—Ç–º–µ–Ω–∏—Ç—å, –Ω–∞–∂–º–∏—Ç–µ /start\"\n    )\n\n\n@router.callback_query(F.data.startswith(\"confirm_card_\"))\nasync def confirm_card_payment(callback: CallbackQuery):\n    \"\"\"Admin confirms card payment\"\"\"\n    try:\n        request_id = int(callback.data.split(\"_\")[2])\n        logger.info(f\"Admin {callback.from_user.id} confirming payment request {request_id}\")\n        \n        async with async_session_maker() as session:\n            payment_repo = CardPaymentRequestRepository(session)\n            request = await payment_repo.get_by_id(request_id)\n            \n            if not request:\n                logger.error(f\"Payment request {request_id} not found\")\n                await callback.answer(\"–ó–∞—è–≤–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞\", show_alert=True)\n                return\n            \n            logger.info(f\"Request found: user_id={request.user_id}, status={request.status}, tokens={request.tokens_amount}\")\n            \n            if request.status != \"pending\":\n                await callback.answer(f\"–ó–∞—è–≤–∫–∞ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞: {request.status}\", show_alert=True)\n                return\n            \n            user_repo = UserRepository(session)\n            user = await user_repo.get_by_id(request.user_id)\n            \n            if not user:\n                logger.error(f\"User with id={request.user_id} not found in database!\")\n                await callback.answer(\"–û—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω\", show_alert=True)\n                return\n            \n            logger.info(f\"User found: id={user.id}, chat_id={user.chat_id}, balance={user.balance}\")\n            \n            result = await user_repo.update_balance(user.chat_id, request.tokens_amount)\n            \n            if not result:\n                await callback.answer(\"–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞\", show_alert=True)\n                return\n            \n            trans_repo = TransactionRepository(session)\n            await trans_repo.create(\n                user_id=request.user_id,\n                amount=request.tokens_amount,\n                reason=f\"–ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–∞—Ä—Ç–æ–π: {request.package_name}\",\n                payment_method=f\"card_{request.card_type}\"\n            )\n            \n            await payment_repo.update_status(request_id, \"completed\", f\"–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ {callback.from_user.full_name}\")\n            \n            user = await user_repo.get_by_id(request.user_id)\n            if user:\n                try:\n                    await callback.bot.send_message(\n                        user.chat_id,\n                        f\"‚úÖ –û–ø–ª–∞—Ç–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞!\\n\\n\"\n                        f\"üì¶ –ù–∞—á–∏—Å–ª–µ–Ω–æ: {request.tokens_amount} —Ç–æ–∫–µ–Ω–æ–≤\\n\"\n                        f\"üí∞ –í–∞—à –±–∞–ª–∞–Ω—Å: {user.balance} —Ç–æ–∫–µ–Ω–æ–≤\\n\\n\"\n                        f\"–°–ø–∞—Å–∏–±–æ –∑–∞ –ø–æ–∫—É–ø–∫—É!\"\n                    )\n                except Exception as e:\n                    logger.error(f\"Failed to notify user {user.chat_id}: {e}\")\n        \n        await callback.message.edit_caption(\n            caption=callback.message.caption + f\"\\n\\n‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ {callback.from_user.full_name}\",\n            reply_markup=None\n        )\n        await callback.answer(\"–û–ø–ª–∞—Ç–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞, —Ç–æ–∫–µ–Ω—ã –Ω–∞—á–∏—Å–ª–µ–Ω—ã!\")\n    \n    except Exception as e:\n        logger.error(f\"Error confirming payment: {e}\", exc_info=True)\n        await callback.answer(\"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞\", show_alert=True)\n\n\n@router.callback_query(F.data.startswith(\"reject_card_\"))\nasync def reject_card_payment(callback: CallbackQuery):\n    \"\"\"Admin rejects card payment\"\"\"\n    try:\n        request_id = int(callback.data.split(\"_\")[2])\n        \n        async with async_session_maker() as session:\n            payment_repo = CardPaymentRequestRepository(session)\n            request = await payment_repo.get_by_id(request_id)\n            \n            if not request:\n                await callback.answer(\"–ó–∞—è–≤–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞\", show_alert=True)\n                return\n            \n            if request.status != \"pending\":\n                await callback.answer(f\"–ó–∞—è–≤–∫–∞ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞: {request.status}\", show_alert=True)\n                return\n            \n            await payment_repo.update_status(request_id, \"rejected\", f\"–û—Ç–∫–ª–æ–Ω–µ–Ω–æ {callback.from_user.full_name}\")\n            \n            user_repo = UserRepository(session)\n            user = await user_repo.get_by_id(request.user_id)\n            if user:\n                try:\n                    await callback.bot.send_message(\n                        user.chat_id,\n                        f\"‚ùå –û–ø–ª–∞—Ç–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞\\n\\n\"\n                        f\"–í–∞—à–∞ –∑–∞—è–≤–∫–∞ –Ω–∞ {request.tokens_amount} —Ç–æ–∫–µ–Ω–æ–≤ –±—ã–ª–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.\\n\"\n                        f\"–ï—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å –≤–æ–ø—Ä–æ—Å—ã, —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π.\"\n                    )\n                except Exception as e:\n                    logger.error(f\"Failed to notify user {user.chat_id}: {e}\")\n        \n        await callback.message.edit_caption(\n            caption=callback.message.caption + f\"\\n\\n‚ùå –û—Ç–∫–ª–æ–Ω–µ–Ω–æ {callback.from_user.full_name}\",\n            reply_markup=None\n        )\n        await callback.answer(\"–ó–∞—è–≤–∫–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞\")\n    \n    except Exception as e:\n        logger.error(f\"Error rejecting payment: {e}\", exc_info=True)\n        await callback.answer(\"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞\", show_alert=True)\n","size_bytes":14618},"app/services/referral.py":{"content":"from sqlalchemy.ext.asyncio import AsyncSession\nfrom app.repositories import UserRepository, ReferralRepository, TransactionRepository\nfrom app.config import settings\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\nclass ReferralService:\n    \"\"\"Service for referral system management\"\"\"\n    \n    def __init__(self, session: AsyncSession):\n        self.session = session\n        self.user_repo = UserRepository(session)\n        self.ref_repo = ReferralRepository(session)\n        self.tx_repo = TransactionRepository(session)\n    \n    async def process_referral_signup(self, referee_chat_id: int, referrer_chat_id: int):\n        \"\"\"Process new user signup via referral link\"\"\"\n        referee = await self.user_repo.get_by_chat_id(referee_chat_id)\n        referrer = await self.user_repo.get_by_chat_id(referrer_chat_id)\n        \n        if referee and referrer and referee.id != referrer.id:\n            await self.ref_repo.create(\n                referrer_id=referrer.id,\n                referee_id=referee.id\n            )\n            logger.info(f\"Referral relationship created: {referrer_chat_id} -> {referee_chat_id}\")\n    \n    async def process_first_purchase(self, buyer_chat_id: int, amount: int):\n        \"\"\"Process first purchase bonus for referee and commission for referrer\"\"\"\n        buyer = await self.user_repo.get_by_chat_id(buyer_chat_id)\n        if not buyer or not buyer.referrer_id:\n            return\n        \n        referrals = await self.ref_repo.get_by_referrer(buyer.referrer_id)\n        buyer_referral = None\n        for ref in referrals:\n            if ref.referee_id == buyer.id:\n                buyer_referral = ref\n                break\n        \n        if not buyer_referral or buyer_referral.first_purchase_bonus_given:\n            return\n        \n        bonus_tokens = settings.referral_bonus\n        await self.user_repo.update_balance(buyer_chat_id, bonus_tokens)\n        await self.tx_repo.create(\n            user_id=buyer.id,\n            amount=bonus_tokens,\n            reason=\"–ë–æ–Ω—É—Å –∑–∞ –ø–µ—Ä–≤—É—é –ø–æ–∫—É–ø–∫—É –ø–æ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–æ–π –ø—Ä–æ–≥—Ä–∞–º–º–µ\"\n        )\n        \n        commission = int(amount * settings.referral_commission / 100)\n        referrer = await self.session.get(User, buyer.referrer_id)\n        if referrer:\n            await self.user_repo.update_balance(referrer.chat_id, commission)\n            await self.tx_repo.create(\n                user_id=referrer.id,\n                amount=commission,\n                reason=f\"–ö–æ–º–∏—Å—Å–∏—è —Å —Ä–µ—Ñ–µ—Ä–∞–ª–∞ (–ø–µ—Ä–≤–∞—è –ø–æ–∫—É–ø–∫–∞)\"\n            )\n            await self.ref_repo.update_earned(buyer_referral.id, commission)\n        \n        buyer_referral.first_purchase_bonus_given = True\n        await self.session.commit()\n        \n        logger.info(f\"First purchase processed: buyer={buyer_chat_id}, bonus={bonus_tokens}, commission={commission}\")\n\n\nfrom app.models import User\n","size_bytes":2928},"app/database.py":{"content":"from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker\nfrom app.models import Base\nfrom app.config import settings\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nengine = create_async_engine(settings.database_url, echo=False)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\n\nasync def init_db():\n    \"\"\"Initialize database tables\"\"\"\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    logger.info(\"Database initialized successfully\")\n\n\nasync def get_session() -> AsyncSession:\n    \"\"\"Get database session\"\"\"\n    async with async_session_maker() as session:\n        yield session\n","size_bytes":712},"app/handlers/referral.py":{"content":"from aiogram import Router, F\nfrom aiogram.filters import Command\nfrom aiogram.types import Message, CallbackQuery\nfrom app.database import async_session_maker\nfrom app.repositories import UserRepository, ReferralRepository\nfrom app.keyboards.inline import back_to_main_keyboard\nfrom app.keyboards.reply import BUTTON_REFERRALS\nfrom app.config import settings\nimport logging\n\nlogger = logging.getLogger(__name__)\nrouter = Router()\n\n\n@router.message(F.text == BUTTON_REFERRALS)\nasync def show_referral_info_message(message: Message):\n    \"\"\"Show referral program information (from reply keyboard button)\"\"\"\n    async with async_session_maker() as session:\n        user_repo = UserRepository(session)\n        user = await user_repo.get_by_chat_id(message.from_user.id)\n        \n        if not user:\n            await message.answer(\"–û—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start\")\n            return\n        \n        ref_repo = ReferralRepository(session)\n        referrals = await ref_repo.get_by_referrer(user.id)\n        \n        total_earned = sum(ref.total_earned for ref in referrals)\n        active_referrals = len(referrals)\n    \n    bot_info = await message.bot.get_me()\n    ref_link = f\"https://t.me/{bot_info.username}?start=ref_{message.from_user.id}\"\n    \n    text = (\n        \"üîó –†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è –ø—Ä–æ–≥—Ä–∞–º–º–∞\\n\\n\"\n        f\"üë• –í–∞—à–∏—Ö —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤: {active_referrals}\\n\"\n        f\"üí∞ –ó–∞—Ä–∞–±–æ—Ç–∞–Ω–æ –≤—Å–µ–≥–æ: {total_earned} —Ç–æ–∫–µ–Ω–æ–≤\\n\\n\"\n        \"üìã –£—Å–ª–æ–≤–∏—è:\\n\"\n        f\"‚Ä¢ –í–∞—à–∏ —Ä–µ—Ñ–µ—Ä–∞–ª—ã –ø–æ–ª—É—á–∞—é—Ç +{settings.referral_bonus} —Ç–æ–∫–µ–Ω–æ–≤ –ø—Ä–∏ –ø–µ—Ä–≤–æ–π –ø–æ–∫—É–ø–∫–µ\\n\"\n        f\"‚Ä¢ –í—ã –ø–æ–ª—É—á–∞–µ—Ç–µ {settings.referral_commission}% —Å –∫–∞–∂–¥–æ–π –∏—Ö –ø–æ–∫—É–ø–∫–∏\\n\\n\"\n        f\"üîó –í–∞—à–∞ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞:\\n\"\n        f\"`{ref_link}`\\n\\n\"\n        \"–ü–æ–¥–µ–ª–∏—Ç–µ—Å—å —Å—Å—ã–ª–∫–æ–π —Å –¥—Ä—É–∑—å—è–º–∏ –∏ –∑–∞—Ä–∞–±–∞—Ç—ã–≤–∞–π—Ç–µ!\"\n    )\n    \n    await message.answer(text, parse_mode=\"Markdown\")\n\n\n@router.message(Command(\"ref\"))\n@router.callback_query(F.data == \"referral_info\")\nasync def show_referral_info(event):\n    \"\"\"Show referral program information\"\"\"\n    user_id = event.from_user.id if isinstance(event, Message) else event.from_user.id\n    \n    async with async_session_maker() as session:\n        user_repo = UserRepository(session)\n        user = await user_repo.get_by_chat_id(user_id)\n        \n        if not user:\n            text = \"–û—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start\"\n            if isinstance(event, Message):\n                await event.answer(text)\n            else:\n                await event.answer(text, show_alert=True)\n            return\n        \n        ref_repo = ReferralRepository(session)\n        referrals = await ref_repo.get_by_referrer(user.id)\n        \n        total_earned = sum(ref.total_earned for ref in referrals)\n        active_referrals = len(referrals)\n    \n    bot_info = await (event.bot if isinstance(event, Message) else event.message.bot).get_me()\n    ref_link = f\"https://t.me/{bot_info.username}?start=ref_{user_id}\"\n    \n    text = (\n        \"üîó –†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è –ø—Ä–æ–≥—Ä–∞–º–º–∞\\n\\n\"\n        f\"üë• –í–∞—à–∏—Ö —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤: {active_referrals}\\n\"\n        f\"üí∞ –ó–∞—Ä–∞–±–æ—Ç–∞–Ω–æ –≤—Å–µ–≥–æ: {total_earned} —Ç–æ–∫–µ–Ω–æ–≤\\n\\n\"\n        \"üìã –£—Å–ª–æ–≤–∏—è:\\n\"\n        f\"‚Ä¢ –í–∞—à–∏ —Ä–µ—Ñ–µ—Ä–∞–ª—ã –ø–æ–ª—É—á–∞—é—Ç +{settings.referral_bonus} —Ç–æ–∫–µ–Ω–æ–≤ –ø—Ä–∏ –ø–µ—Ä–≤–æ–π –ø–æ–∫—É–ø–∫–µ\\n\"\n        f\"‚Ä¢ –í—ã –ø–æ–ª—É—á–∞–µ—Ç–µ {settings.referral_commission}% —Å –∫–∞–∂–¥–æ–π –∏—Ö –ø–æ–∫—É–ø–∫–∏\\n\\n\"\n        f\"üîó –í–∞—à–∞ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞:\\n\"\n        f\"`{ref_link}`\\n\\n\"\n        \"–ü–æ–¥–µ–ª–∏—Ç–µ—Å—å —Å—Å—ã–ª–∫–æ–π —Å –¥—Ä—É–∑—å—è–º–∏ –∏ –∑–∞—Ä–∞–±–∞—Ç—ã–≤–∞–π—Ç–µ!\"\n    )\n    \n    keyboard = back_to_main_keyboard()\n    \n    if isinstance(event, Message):\n        await event.answer(text, reply_markup=keyboard, parse_mode=\"Markdown\")\n    else:\n        await event.message.edit_text(text, reply_markup=keyboard, parse_mode=\"Markdown\")\n        await event.answer()\n","size_bytes":4194},"app/services/crypto_payment.py":{"content":"from aiocryptopay import AioCryptoPay, Networks\nfrom app.config import settings\nfrom typing import Optional, Dict\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\nclass CryptoPaymentService:\n    \"\"\"Service for CryptoBot payments\"\"\"\n    \n    def __init__(self):\n        self.crypto = AioCryptoPay(\n            token=settings.CRYPTO_BOT_TOKEN,\n            network=Networks.MAIN_NET\n        )\n    \n    async def create_invoice(\n        self,\n        amount: float,\n        currency: str = \"USDT\",\n        description: str = \"–ü–æ–∫—É–ø–∫–∞ —Ç–æ–∫–µ–Ω–æ–≤\"\n    ) -> Optional[Dict]:\n        \"\"\"\n        Create payment invoice\n        \n        Args:\n            amount: Payment amount\n            currency: Cryptocurrency (USDT, TON, BTC, etc)\n            description: Payment description\n            \n        Returns:\n            Dict with invoice_id, pay_url, amount or None on error\n        \"\"\"\n        try:\n            invoice = await self.crypto.create_invoice(\n                asset=currency,\n                amount=amount,\n                description=description\n            )\n            logger.info(f\"Invoice created: {invoice.invoice_id} for {amount} {currency}\")\n            return {\n                \"invoice_id\": invoice.invoice_id,\n                \"pay_url\": invoice.bot_invoice_url,\n                \"amount\": invoice.amount,\n                \"currency\": currency\n            }\n        except Exception as e:\n            logger.error(f\"Failed to create invoice: {e}\")\n            return None\n    \n    async def check_invoice(self, invoice_id: int) -> bool:\n        \"\"\"\n        Check if invoice is paid\n        \n        Args:\n            invoice_id: Invoice ID to check\n            \n        Returns:\n            True if paid, False otherwise\n        \"\"\"\n        try:\n            invoices = await self.crypto.get_invoices(invoice_ids=[invoice_id])\n            if invoices and len(invoices) > 0:\n                is_paid = invoices[0].status == \"paid\"\n                logger.info(f\"Invoice {invoice_id} status: {invoices[0].status}\")\n                return is_paid\n            return False\n        except Exception as e:\n            logger.error(f\"Failed to check invoice: {e}\")\n            return False\n","size_bytes":2212},"app/__init__.py":{"content":"","size_bytes":0},"app/handlers/payment.py":{"content":"from aiogram import Router, F\nfrom aiogram.filters import Command\nfrom aiogram.types import Message, CallbackQuery\nfrom app.database import async_session_maker\nfrom app.repositories import UserRepository, TransactionRepository\nfrom app.services.crypto_payment import CryptoPaymentService\nfrom app.services.billing import BillingService\nfrom app.services.referral import ReferralService\nfrom app.keyboards.inline import buy_tokens_keyboard, crypto_payment_keyboard, back_to_main_keyboard\nfrom app.keyboards.reply import BUTTON_BUY_TOKENS\nimport logging\n\nlogger = logging.getLogger(__name__)\nrouter = Router()\n\n\n@router.message(F.text == BUTTON_BUY_TOKENS)\nasync def show_buy_menu_message(message: Message):\n    \"\"\"Show buy tokens menu (from reply keyboard button)\"\"\"\n    text = (\n        \"üí∞ –ü–æ–∫—É–ø–∫–∞ —Ç–æ–∫–µ–Ω–æ–≤\\n\\n\"\n        \"–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞–∫–µ—Ç:\\n\"\n    )\n    \n    packages = BillingService.get_all_packages()\n    for pack in packages:\n        discount_text = f\" (-{pack['discount']}%)\" if pack.get('discount', 0) > 0 else \"\"\n        text += f\"‚Ä¢ {pack['tokens']} —Ç–æ–∫–µ–Ω–æ–≤ = {pack['stars']} Stars{discount_text}\\n\"\n    \n    text += \"\\nüíé –¢–∞–∫–∂–µ –¥–æ—Å—Ç—É–ø–Ω–∞ –æ–ø–ª–∞—Ç–∞ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–æ–π –∏ –∫–∞—Ä—Ç–æ–π\"\n    \n    await message.answer(text, reply_markup=buy_tokens_keyboard())\n\n\n@router.message(Command(\"buy\"))\n@router.callback_query(F.data == \"buy_menu\")\nasync def show_buy_menu(event):\n    \"\"\"Show buy tokens menu\"\"\"\n    text = (\n        \"üí∞ –ü–æ–∫—É–ø–∫–∞ —Ç–æ–∫–µ–Ω–æ–≤\\n\\n\"\n        \"–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞–∫–µ—Ç:\\n\"\n    )\n    \n    packages = BillingService.get_all_packages()\n    for pack in packages:\n        discount_text = f\" (-{pack['discount']}%)\" if pack.get('discount', 0) > 0 else \"\"\n        text += f\"‚Ä¢ {pack['tokens']} —Ç–æ–∫–µ–Ω–æ–≤ = {pack['stars']} Stars{discount_text}\\n\"\n    \n    text += \"\\nüíé –¢–∞–∫–∂–µ –¥–æ—Å—Ç—É–ø–Ω–∞ –æ–ø–ª–∞—Ç–∞ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–æ–π\"\n    \n    if isinstance(event, Message):\n        await event.answer(text, reply_markup=buy_tokens_keyboard())\n    else:\n        await event.message.edit_text(text, reply_markup=buy_tokens_keyboard())\n        await event.answer()\n\n\n\n\n@router.callback_query(F.data == \"buy_crypto_menu\")\nasync def show_crypto_menu(callback: CallbackQuery):\n    \"\"\"Show crypto payment menu\"\"\"\n    text = (\n        \"üíé –û–ø–ª–∞—Ç–∞ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–æ–π\\n\\n\"\n        \"–í—ã–±–µ—Ä–∏—Ç–µ –≤–∞–ª—é—Ç—É:\\n\"\n        \"‚Ä¢ USDT (TRC-20)\\n\"\n        \"‚Ä¢ TON\\n\"\n        \"‚Ä¢ Bitcoin\\n\\n\"\n        \"–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞: $5\"\n    )\n    \n    await callback.message.edit_text(text, reply_markup=crypto_payment_keyboard())\n    await callback.answer()\n\n\n@router.callback_query(F.data.startswith(\"crypto_\"))\nasync def create_crypto_invoice(callback: CallbackQuery):\n    \"\"\"Create crypto payment invoice\"\"\"\n    currency = callback.data.split(\"_\")[1].upper()\n    \n    await callback.message.edit_text(\n        f\"üíé –û–ø–ª–∞—Ç–∞ —á–µ—Ä–µ–∑ {currency}\\n\\n\"\n        \"–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –≤ USD (–º–∏–Ω–∏–º—É–º $5):\\n\"\n        \"–ù–∞–ø—Ä–∏–º–µ—Ä: 10\",\n        reply_markup=back_to_main_keyboard()\n    )\n    \n    await callback.answer()\n\n\n@router.callback_query(F.data == \"buy_stars_alt_menu\")\nasync def show_stars_alt_menu(callback: CallbackQuery):\n    \"\"\"Show alternative Stars payment menu\"\"\"\n    from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n    \n    text = (\n        \"‚≠ê –û–ø–ª–∞—Ç–∞ Telegram Stars\\n\\n\"\n        \"–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞–∫–µ—Ç —Ç–æ–∫–µ–Ω–æ–≤ –¥–ª—è –æ–ø–ª–∞—Ç—ã —á–µ—Ä–µ–∑ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –±–æ—Ç:\\n\"\n    )\n    \n    packages = BillingService.get_all_packages()\n    buttons = []\n    \n    for pack in packages:\n        tokens = pack[\"tokens\"]\n        stars = pack[\"stars\"]\n        discount = pack.get(\"discount\", 0)\n        \n        btn_text = f\"‚≠êÔ∏è {tokens} —Ç–æ–∫–µ–Ω–æ–≤ ({stars} Stars\"\n        if discount > 0:\n            btn_text += f\", -{discount}%\"\n        btn_text += \")\"\n        \n        buttons.append([InlineKeyboardButton(\n            text=btn_text,\n            callback_data=f\"buy_stars_alt_{tokens}\"\n        )])\n    \n    buttons.append([InlineKeyboardButton(\n        text=\"‚óÄÔ∏è –ù–∞–∑–∞–¥\",\n        callback_data=\"buy_menu\"\n    )])\n    \n    keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)\n    \n    await callback.message.edit_text(text, reply_markup=keyboard)\n    await callback.answer()\n\n\n@router.callback_query(F.data.startswith(\"buy_stars_alt_\"))\nasync def buy_stars_alt_package(callback: CallbackQuery):\n    \"\"\"Create invoice link using alternative bot for Stars payment\"\"\"\n    try:\n        tokens = int(callback.data.split(\"_\")[3])\n        package = BillingService.get_stars_package(tokens)\n        \n        if not package:\n            await callback.answer(\"–ü–∞–∫–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω\", show_alert=True)\n            return\n        \n        stars = package[\"stars\"]\n        \n        # Create invoice link using ALTERNATIVE bot (ALT_BOT_TOKEN)\n        import aiohttp\n        from app.config import settings\n        \n        bot_token = settings.ALT_BOT_TOKEN\n        \n        invoice_data = {\n            \"title\": f\"–ü–æ–∫—É–ø–∫–∞ {tokens} —Ç–æ–∫–µ–Ω–æ–≤\",\n            \"description\": f\"–ü–∞–∫–µ—Ç —Ç–æ–∫–µ–Ω–æ–≤ –¥–ª—è AI-–≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏ –≤–∏–¥–µ–æ\",\n            \"payload\": f\"tokens_{tokens}_{callback.from_user.id}\",\n            \"provider_token\": \"\",\n            \"currency\": \"XTR\",\n            \"prices\": [{\"label\": f\"{tokens} —Ç–æ–∫–µ–Ω–æ–≤\", \"amount\": stars}]\n        }\n        \n        async with aiohttp.ClientSession() as session:\n            async with session.post(\n                f\"https://api.telegram.org/bot{bot_token}/createInvoiceLink\",\n                json=invoice_data\n            ) as resp:\n                if resp.status == 200:\n                    data = await resp.json()\n                    if data.get(\"ok\"):\n                        invoice_link = data[\"result\"]\n                        \n                        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n                        keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                            [InlineKeyboardButton(text=\"‚≠ê –û–ø–ª–∞—Ç–∏—Ç—å Stars\", url=invoice_link)],\n                            [InlineKeyboardButton(text=\"‚óÄÔ∏è –ù–∞–∑–∞–¥\", callback_data=\"buy_stars_alt_menu\")]\n                        ])\n                        \n                        await callback.message.edit_text(\n                            f\"‚≠ê –û–ø–ª–∞—Ç–∞ {tokens} —Ç–æ–∫–µ–Ω–æ–≤\\n\\n\"\n                            f\"üí∞ –°—Ç–æ–∏–º–æ—Å—Ç—å: {stars} Stars\\n\\n\"\n                            \"–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ –¥–ª—è –æ–ø–ª–∞—Ç—ã:\",\n                            reply_markup=keyboard\n                        )\n                        await callback.answer()\n                    else:\n                        logger.error(f\"Failed to create invoice link: {data}\")\n                        await callback.answer(\"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å—Å—ã–ª–∫–∏ –Ω–∞ –æ–ø–ª–∞—Ç—É\", show_alert=True)\n                else:\n                    logger.error(f\"API error creating invoice link: {resp.status}\")\n                    await callback.answer(\"–û—à–∏–±–∫–∞ API\", show_alert=True)\n                    \n    except Exception as e:\n        logger.error(f\"Error creating alternative invoice: {e}\", exc_info=True)\n        await callback.answer(\"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å—á–µ—Ç–∞\", show_alert=True)\n","size_bytes":7435},"app/keyboards/__init__.py":{"content":"","size_bytes":0},"app/middlewares/__init__.py":{"content":"","size_bytes":0}},"version":2}